{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>ili2py is the IlisMeta16 model (IMD16) in python. Its aim is to natively implement the understanding of the IMD16 representation of any ili model in python. It is a bridge library which can be used to build python applications on top.</p> <p>In its core ili2py offers handy mappers and indexed access to all constructs of the IMD16. This includes:</p> <ul> <li>classes and their attributes</li> <li>constraints</li> <li>geometries (incl. multi)</li> <li>structures</li> <li>associations</li> <li>and many many more...</li> </ul> <p>On top ili2py offers already some built in applications to demonstrate its potential. These can be used directly out of python or with an easy-to-use CLI.</p>"},{"location":"#diagrams","title":"Diagrams","text":"<p>This program generates UML diagrams of different flavourss. Its advanced features are:</p> <ul> <li>multiple TOPICS and MODELS in one diagram to vizualize the broader context</li> <li>fine-grained settings for direction, distance and connector types</li> <li>filter to select which models should be drawn</li> <li>import based depth filter to easily filter diagram content</li> <li>and more...</li> </ul> <p>Consult the Userguide for more info.</p>"},{"location":"#python-classes","title":"Python Classes","text":"<p>This program generates Python Classes representing 1:1 the classes defined in the Interlis model. Its advanced features are:</p> <ul> <li>complete standalone python package structure reflecting the desired interlis model</li> <li>based on python native dataclasses (100% no 3rd party dependencies)</li> <li>utilizes:<ul> <li>associations</li> <li>constraints</li> <li>meta attributes</li> <li>enumerations</li> <li>geometries</li> <li>documentation</li> </ul> </li> <li>delivers a well-structured and ready to use python package</li> <li>enables comfortable coding (autocompletion, jump-to-definition, documentation, ...)</li> <li>and many many more...</li> </ul> <p>Consult the Userguide for more info.</p>"},{"location":"#whats-next","title":"What's next","text":"<p>There are already ideas and follow-up projects around. Feel free to reach out if you are interested in those, or you have an idea you want to discuss.</p>"},{"location":"#qgis-xtf-object-browser","title":"QGIS XTF Object browser","text":"<p>This quick draft to show how we could navigate through the objects loaded from an XTF via the python classes generated by ili2py. Only feature we use here is the layers which contains the geometry and a field for the OID. All the rest happens in memory in the object world. No ORM in place! Since we are able to read/write valid XTF with the python classes, the next steps are obvious: Instead of only showing the information we can make it editable. This would enable quick inspection of Interlis data, to fix typos or other stuff including geometries.</p>"},{"location":"#interlis-object-flow","title":"Interlis Object Flow","text":"<p>This quick draft based on ili2py and the generated classes shows a QT (PyQT) canvas with nodes and ports to create data flows to ETL XTF's directly. Because its QT it natively integrates with Python and QGIS. The infinite canvas allows positioning of nodes all around. Patching ports of nodes with connectors to other nodes. All elements including their position can bei serialized and therefore be stored. A styling inteface already allows customization.</p> <p>First usecases coming into my mind are:</p> <ul> <li>inter-model-transformer like MGDM2OEREB (but with a nice GUI and without XSLT)</li> <li>XTF merger (when you have xtfs handled municipality wise)</li> </ul> <p>Besides that, it would be a good foundation to a modern and easy to use UML editor.</p>"},{"location":"build_executable/","title":"Build executable","text":"<p>Binary distributions are produces with PyInstaller.</p>"},{"location":"code/ilismeta16/","title":"IlisMeta16","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.DataSection","title":"<code>DataSection</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/__init__.py</code> <pre><code>@dataclass(kw_only=True)\nclass DataSection:\n\n    ModelData: list[\"Imd_ModelData\"] = field(\n        default_factory=list,\n        metadata={\n            \"type\": \"Elements\",\n            \"choices\": (\n                {\n                    \"name\": \"ModelData\",\n                    \"type\": Imd_ModelData,\n                    \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n                },\n            ),\n        },\n    )\n    ModelTranslation: list[\"Imd_ModelTranslation\"] = field(\n        default_factory=list,\n        metadata={\n            \"type\": \"Elements\",\n            \"choices\": (\n                {\n                    \"name\": \"ModelTranslation\",\n                    \"type\": Imd_ModelTranslation,\n                    \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n                },\n            ),\n        },\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.DataSection.ModelData","title":"<code>ModelData = field(default_factory=list, metadata={'type': 'Elements', 'choices': ({'name': 'ModelData', 'type': Imd_ModelData, 'namespace': imd_namespace_map['IlisMeta16']})})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.DataSection.ModelTranslation","title":"<code>ModelTranslation = field(default_factory=list, metadata={'type': 'Elements', 'choices': ({'name': 'ModelTranslation', 'type': Imd_ModelTranslation, 'namespace': imd_namespace_map['IlisMeta16']})})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.DataSection.__init__","title":"<code>__init__(*, ModelData=list(), ModelTranslation=list())</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.ImdTransfer","title":"<code>ImdTransfer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Transfer</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/__init__.py</code> <pre><code>@dataclass(kw_only=True)\nclass ImdTransfer(Transfer):\n\n    datasection: DataSection = field(metadata={\"namespace\": imd_namespace_map[\"ili\"]})\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.ImdTransfer.datasection","title":"<code>datasection = field(metadata={'namespace': imd_namespace_map['ili']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.ImdTransfer.__init__","title":"<code>__init__(headersection, *, datasection)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.helper","title":"<code>helper</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.helper.index_modeldata","title":"<code>index_modeldata(transfer)</code>","text":"<p>Little helper method to perform the indexing of the metamodel information in an easy-to-use one dimensional tree. Args:     transfer: The full metamodel tree of dataclass objects which should be indexed.</p> <p>Returns: The index containing the already resolved references between the dataclass objects.</p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/helper.py</code> <pre><code>def index_modeldata(transfer: ImdTransfer) -&gt; dict:\n    \"\"\"\n    Little helper method to perform the indexing of the metamodel information in an\n    easy-to-use one dimensional tree.\n    Args:\n        transfer: The full metamodel tree of dataclass objects which should be indexed.\n\n    Returns: The index containing the already resolved references between the dataclass objects.\n    \"\"\"\n\n    index = {}\n    for item in transfer.datasection.ModelData:\n        unwrap_tree(item, index)\n\n    resolve_references(index)\n    return index\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.helper.resolve_references","title":"<code>resolve_references(index)</code>","text":"<p>Little helper method to resolve references in the index based on the REF elements.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>dict</code> <p>The index with all the elements identifiable by their unique key.</p> required Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/helper.py</code> <pre><code>def resolve_references(index: dict):\n    \"\"\"\n    Little helper method to resolve references in the index based on the REF elements.\n\n    Args:\n        index: The index with all the elements identifiable by their unique key.\n    \"\"\"\n    for key in index:\n        if isinstance(index[key], HasRef):\n            index[key].resolve_refs(index)\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.helper.unwrap_tree","title":"<code>unwrap_tree(element, index)</code>","text":"<p>A little helper method to assemble a one dimensional index with the elements unique identifiers tid as the key.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>dict</code> <p>the dictionary which should be filled with the elements.</p> required Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/helper.py</code> <pre><code>def unwrap_tree(element: object, index: dict):\n    \"\"\"\n    A little helper method to assemble a one dimensional index with the elements unique\n    identifiers *tid* as the key.\n\n    Args:\n        index: the dictionary which should be filled with the elements.\n    \"\"\"\n    if hasattr(element, \"__annotations__\"):\n        if hasattr(element, \"tid\"):\n            # the element has already a unique identifier. we can use this in the index\n            if element.tid in index:\n                raise LookupError(f\"Element {element.tid} was already in tree. Thats not allowed!\")\n        else:\n            # the element does not have a unique idendtifier (usually relations) we will set up a runtime\n            # one to make linking possible\n            setattr(element, \"tid\", f\"{element.__class__.__name__}.{str(uuid4())}\")\n        index[element.tid] = element\n        for attribute in element.__annotations__:\n            member = element.__getattribute__(attribute)\n            if isinstance(member, list):\n                for item in member:\n                    unwrap_tree(item, index)\n            else:\n                unwrap_tree(member, index)\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data","title":"<code>model_data</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element","title":"<code>abstract_element</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.AbstractElement","title":"<code>AbstractElement</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/abstract_element.py</code> <pre><code>@dataclass\nclass AbstractElement:\n    pass\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.AbstractElement.__init__","title":"<code>__init__()</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.DocTextElement","title":"<code>DocTextElement</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AbstractElement</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/abstract_element.py</code> <pre><code>@dataclass\nclass DocTextElement(AbstractElement):\n\n    Text: str = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    Name: Optional[str] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.DocTextElement.Name","title":"<code>Name = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.DocTextElement.Text","title":"<code>Text = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.DocTextElement.__init__","title":"<code>__init__(Text, Name=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement","title":"<code>Ili1FormatElement</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AbstractElement</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/abstract_element.py</code> <pre><code>@dataclass\nclass Ili1FormatElement(AbstractElement):\n\n    class TidKind(StrEnum):\n        TID_I16 = auto()\n        TID_I32 = auto()\n        TID_ANY = auto()\n        TID_EXPLANATION = auto()\n\n    isFree: bool = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    blankCode: int = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    undefinedCode: int = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    continueCode: int = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    Font: str = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    tidKind: TidKind = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    LineSize: Optional[int] = field(\n        default=None,\n        metadata={\n            \"type\": \"Attribute\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    tidSize: Optional[int] = field(\n        default=None,\n        metadata={\n            \"type\": \"Attribute\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    tidExplanation: Optional[str] = field(\n        default=None,\n        metadata={\n            \"type\": \"Attribute\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.Font","title":"<code>Font = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.LineSize","title":"<code>LineSize = field(default=None, metadata={'type': 'Attribute', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.blankCode","title":"<code>blankCode = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.continueCode","title":"<code>continueCode = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.isFree","title":"<code>isFree = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.tidExplanation","title":"<code>tidExplanation = field(default=None, metadata={'type': 'Attribute', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.tidKind","title":"<code>tidKind = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.tidSize","title":"<code>tidSize = field(default=None, metadata={'type': 'Attribute', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.undefinedCode","title":"<code>undefinedCode = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.TidKind","title":"<code>TidKind</code>","text":"<p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/abstract_element.py</code> <pre><code>class TidKind(StrEnum):\n    TID_I16 = auto()\n    TID_I32 = auto()\n    TID_ANY = auto()\n    TID_EXPLANATION = auto()\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.TidKind.TID_ANY","title":"<code>TID_ANY = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.TidKind.TID_EXPLANATION","title":"<code>TID_EXPLANATION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.TidKind.TID_I16","title":"<code>TID_I16 = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.TidKind.TID_I32","title":"<code>TID_I32 = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.Ili1FormatElement.__init__","title":"<code>__init__(isFree, blankCode, undefinedCode, continueCode, Font, tidKind, LineSize=None, tidSize=None, tidExplanation=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.MetaAttributeElement","title":"<code>MetaAttributeElement</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HasRef</code>, <code>AbstractElement</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/abstract_element.py</code> <pre><code>@dataclass\nclass MetaAttributeElement(HasRef, AbstractElement):\n\n    Name: str = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    Value: str = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    tid: str = field(metadata={\"type\": \"Attribute\", \"namespace\": imd_namespace_map[\"ili\"]})\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    MetaElement_ref: Ref = field(\n        metadata={\n            \"name\": \"MetaElement\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.MetaAttributeElement.MetaElement_ref","title":"<code>MetaElement_ref = field(metadata={'name': 'MetaElement', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.MetaAttributeElement.Name","title":"<code>Name = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.MetaAttributeElement.Value","title":"<code>Value = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.MetaAttributeElement.tid","title":"<code>tid = field(metadata={'type': 'Attribute', 'namespace': imd_namespace_map['ili']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.abstract_element.MetaAttributeElement.__init__","title":"<code>__init__(Name, Value, tid, MetaElement_ref)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints","title":"<code>constraints</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.Constraint","title":"<code>Constraint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MetaElement</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/constraints.py</code> <pre><code>@dataclass\nclass Constraint(MetaElement):\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    ToClass_ref: Ref = field(\n        metadata={\n            \"name\": \"ToClass\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.Constraint.ToClass_ref","title":"<code>ToClass_ref = field(metadata={'name': 'ToClass', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.Constraint.__init__","title":"<code>__init__(ToClass_ref, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.SimpleConstraint","title":"<code>SimpleConstraint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Constraint</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/constraints.py</code> <pre><code>@dataclass\nclass SimpleConstraint(Constraint):\n    class KindEnum(StrEnum):\n        MandC = auto()\n        LowPercC = auto()\n        HighPercC = auto()\n\n    Kind: KindEnum = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    LogicalExpression: CompoundExprElement = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    Percentage: Optional[float] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.SimpleConstraint.Kind","title":"<code>Kind = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.SimpleConstraint.LogicalExpression","title":"<code>LogicalExpression = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.SimpleConstraint.Percentage","title":"<code>Percentage = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.SimpleConstraint.KindEnum","title":"<code>KindEnum</code>","text":"<p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/constraints.py</code> <pre><code>class KindEnum(StrEnum):\n    MandC = auto()\n    LowPercC = auto()\n    HighPercC = auto()\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.SimpleConstraint.KindEnum.HighPercC","title":"<code>HighPercC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.SimpleConstraint.KindEnum.LowPercC","title":"<code>LowPercC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.SimpleConstraint.KindEnum.MandC","title":"<code>MandC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.constraints.SimpleConstraint.__init__","title":"<code>__init__(ToClass_ref, Kind=None, LogicalExpression=None, Percentage=None, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me","title":"<code>extendable_me</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me","title":"<code>extendable_me</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.AttrOrParam","title":"<code>AttrOrParam</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ExtendableMe</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/extendable_me.py</code> <pre><code>@dataclass\nclass AttrOrParam(ExtendableMe):\n\n    class SubdivisionKindEnum(StrEnum):\n        NoSubDiv = auto()\n        SubDiv = auto()\n        ContSubDiv = auto()\n\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    Type_ref: Ref = field(metadata={\"name\": \"Type\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    SubdivisionKind: SubdivisionKindEnum = None\n    Transient: Optional[bool] = None\n    Derivates: Optional[List[Expression]] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    AttrParent_ref: Optional[OrderedRef] = field(\n        default=None,\n        metadata={\"name\": \"AttrParent\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n    )\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    ParamParent_ref: Optional[OrderedRef] = field(\n        default=None,\n        metadata={\"name\": \"ParamParent\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.AttrOrParam.AttrParent_ref","title":"<code>AttrParent_ref = field(default=None, metadata={'name': 'AttrParent', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.AttrOrParam.Derivates","title":"<code>Derivates = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.AttrOrParam.ParamParent_ref","title":"<code>ParamParent_ref = field(default=None, metadata={'name': 'ParamParent', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.AttrOrParam.SubdivisionKind","title":"<code>SubdivisionKind = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.AttrOrParam.Transient","title":"<code>Transient = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.AttrOrParam.Type_ref","title":"<code>Type_ref = field(metadata={'name': 'Type', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.AttrOrParam.SubdivisionKindEnum","title":"<code>SubdivisionKindEnum</code>","text":"<p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/extendable_me.py</code> <pre><code>class SubdivisionKindEnum(StrEnum):\n    NoSubDiv = auto()\n    SubDiv = auto()\n    ContSubDiv = auto()\n</code></pre> <code>ContSubDiv = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>NoSubDiv = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>SubDiv = auto()</code> <code>class-attribute</code> <code>instance-attribute</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.AttrOrParam.__init__","title":"<code>__init__(Type_ref, SubdivisionKind=None, Transient=None, Derivates=list(), AttrParent_ref=None, ParamParent_ref=None, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.DataUnit","title":"<code>DataUnit</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ExtendableMe</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/extendable_me.py</code> <pre><code>@dataclass\nclass DataUnit(ExtendableMe):\n    name = \"BASKET\"\n    ViewUnit: bool = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    DataUnitName: str = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.DataUnit.DataUnitName","title":"<code>DataUnitName = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.DataUnit.ViewUnit","title":"<code>ViewUnit = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.DataUnit.name","title":"<code>name = 'BASKET'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.DataUnit.__init__","title":"<code>__init__(ViewUnit, DataUnitName, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.EnumNode","title":"<code>EnumNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ExtendableMe</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/extendable_me.py</code> <pre><code>@dataclass\nclass EnumNode(ExtendableMe):\n\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    EnumType_ref: Optional[OrderedRef] = field(\n        default=None, metadata={\"name\": \"EnumType\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    ParentNode_ref: Optional[OrderedRef] = field(\n        default=None, metadata={\"name\": \"ParentNode\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.EnumNode.EnumType_ref","title":"<code>EnumType_ref = field(default=None, metadata={'name': 'EnumType', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.EnumNode.ParentNode_ref","title":"<code>ParentNode_ref = field(default=None, metadata={'name': 'ParentNode', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.EnumNode.__init__","title":"<code>__init__(EnumType_ref=None, ParentNode_ref=None, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.ExtendableMe","title":"<code>ExtendableMe</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MetaElement</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/extendable_me.py</code> <pre><code>@dataclass(kw_only=True)\nclass ExtendableMe(MetaElement):\n\n    Abstract: bool = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    Final: bool = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    Super_ref: Optional[Ref] = field(\n        default=None,\n        metadata={\"name\": \"Super\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n    )\n    # Only available in interlis model_data since 2.4\n    # TODO: Find way to create class according to the parsed version in imd\n    Generic: bool = field(\n        default=None,\n        metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.ExtendableMe.Abstract","title":"<code>Abstract = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.ExtendableMe.Final","title":"<code>Final = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.ExtendableMe.Generic","title":"<code>Generic = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.ExtendableMe.Super_ref","title":"<code>Super_ref = field(default=None, metadata={'name': 'Super', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.ExtendableMe.__init__","title":"<code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.Unit","title":"<code>Unit</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ExtendableMe</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/extendable_me.py</code> <pre><code>@dataclass\nclass Unit(ExtendableMe):\n\n    class KindEnum(StrEnum):\n        BaseU = auto()\n        DerivedU = auto()\n        ComposedU = auto()\n\n    Kind: KindEnum = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.Unit.Kind","title":"<code>Kind = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.Unit.KindEnum","title":"<code>KindEnum</code>","text":"<p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/extendable_me.py</code> <pre><code>class KindEnum(StrEnum):\n    BaseU = auto()\n    DerivedU = auto()\n    ComposedU = auto()\n</code></pre> <code>BaseU = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>ComposedU = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>DerivedU = auto()</code> <code>class-attribute</code> <code>instance-attribute</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.extendable_me.Unit.__init__","title":"<code>__init__(Kind, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type","title":"<code>type</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type.domain_type","title":"<code>domain_type</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type.domain_type.class_related_type","title":"<code>class_related_type</code>","text":"<code>class_related_type</code> <code>ClassRefType</code> <code>dataclass</code> <p>               Bases: <code>ClassRelatedType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/class_related_type/class_related_type.py</code> <pre><code>@dataclass\nclass ClassRefType(ClassRelatedType):\n    pass\n</code></pre> <code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>ClassRelatedType</code> <code>dataclass</code> <p>               Bases: <code>DomainType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/class_related_type/class_related_type.py</code> <pre><code>@dataclass\nclass ClassRelatedType(DomainType):\n    pass\n</code></pre> <code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>ObjectType</code> <code>dataclass</code> <p>               Bases: <code>ClassRelatedType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/class_related_type/class_related_type.py</code> <pre><code>@dataclass\nclass ObjectType(ClassRelatedType):\n    Multiple: bool = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n</code></pre> <code>Multiple = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Multiple, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>ReferenceType</code> <code>dataclass</code> <p>               Bases: <code>ClassRelatedType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/class_related_type/class_related_type.py</code> <pre><code>@dataclass\nclass ReferenceType(ClassRelatedType):\n    External: bool = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n</code></pre> <code>External = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(External, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>role</code> <code>Role</code> <code>dataclass</code> <p>               Bases: <code>ReferenceType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/class_related_type/role.py</code> <pre><code>@dataclass\nclass Role(ReferenceType):\n\n    class StrongnessEnum(StrEnum):\n        Assoc = auto()\n        Aggr = auto()\n        Comp = auto()\n\n    @dataclass\n    class _Multiplicity:\n        Multiplicity: Optional[MultiplicityElement] = field(\n            default=None,\n            metadata={\n                \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n            },\n        )\n\n    Strongness: StrongnessEnum = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n    Ordered: bool = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n    EmbeddedTransfer: bool = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    Association_ref: OrderedRef = field(\n        metadata={\"name\": \"Association\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    Multiplicity: Optional[\"Role._Multiplicity\"] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n</code></pre> <code>Association_ref = field(metadata={'name': 'Association', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>EmbeddedTransfer = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Multiplicity = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Ordered = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Strongness = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>StrongnessEnum</code> <p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/class_related_type/role.py</code> <pre><code>class StrongnessEnum(StrEnum):\n    Assoc = auto()\n    Aggr = auto()\n    Comp = auto()\n</code></pre> <code>Aggr = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Assoc = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Comp = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>_Multiplicity</code> <code>dataclass</code> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/class_related_type/role.py</code> <pre><code>@dataclass\nclass _Multiplicity:\n    Multiplicity: Optional[MultiplicityElement] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n</code></pre> <code>Multiplicity = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Multiplicity=None)</code> <code>__init__(External, Strongness, Ordered, EmbeddedTransfer, Association_ref, Multiplicity=None, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type.domain_type.domain_type","title":"<code>domain_type</code>","text":"<code>AxisSpec</code> <code>dataclass</code> <p>               Bases: <code>HasRef</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass\nclass AxisSpec(HasRef):\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    CoordType_ref: Ref = field(\n        metadata={\"name\": \"CoordType\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n    )\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    Axis_ref: OrderedRef = field(\n        metadata={\"name\": \"Axis\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n    )\n</code></pre> <code>Axis_ref = field(metadata={'name': 'Axis', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>CoordType_ref = field(metadata={'name': 'CoordType', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(CoordType_ref, Axis_ref)</code> <code>BlackboxType</code> <code>dataclass</code> <p>               Bases: <code>DomainType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass\nclass BlackboxType(DomainType):\n    class KindEnum(StrEnum):\n        Binary = auto()\n        Xml = auto()\n\n    Kind: KindEnum = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n</code></pre> <code>Kind = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>KindEnum</code> <p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>class KindEnum(StrEnum):\n    Binary = auto()\n    Xml = auto()\n</code></pre> <code>Binary = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Xml = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Kind, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>BooleanType</code> <code>dataclass</code> <p>               Bases: <code>DomainType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass\nclass BooleanType(DomainType):\n    pass\n</code></pre> <code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>CoordType</code> <code>dataclass</code> <p>               Bases: <code>DomainType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass\nclass CoordType(DomainType):\n\n    NullAxis: Optional[int] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    PiHalfAxis: Optional[int] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    # Only available in interlis model_data since 2.4\n    Multi: Optional[bool] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n</code></pre> <code>Multi = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>NullAxis = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>PiHalfAxis = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(NullAxis=None, PiHalfAxis=None, Multi=None, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>DomainType</code> <code>dataclass</code> <p>               Bases: <code>Type</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass(kw_only=True)\nclass DomainType(Type):\n    Mandatory: bool = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n</code></pre> <code>Mandatory = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>EnumType</code> <code>dataclass</code> <p>               Bases: <code>DomainType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass\nclass EnumType(DomainType):\n\n    class OrderEnum(StrEnum):\n        Unordered = auto()\n        Ordered = auto()\n        Circular = auto()\n\n    Order: OrderEnum = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n</code></pre> <code>Order = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>OrderEnum</code> <p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>class OrderEnum(StrEnum):\n    Unordered = auto()\n    Ordered = auto()\n    Circular = auto()\n</code></pre> <code>Circular = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Ordered = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Unordered = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Order, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>FormattedType</code> <code>dataclass</code> <p>               Bases: <code>NumType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass(kw_only=True)\nclass FormattedType(NumType):\n\n    Format: str = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    Struct_ref: Ref = field(\n        metadata={\"name\": \"Struct\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n</code></pre> <code>Format = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Struct_ref = field(metadata={'name': 'Struct', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory, Min=None, Max=None, Circular=None, Clockwise=None, Unit_ref=None, Format, Struct_ref)</code> <code>LineType</code> <code>dataclass</code> <p>               Bases: <code>DomainType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass\nclass LineType(DomainType):\n    class KindEnum(StrEnum):\n        Polyline = auto()\n        DirectedPolyline = auto()\n        Area = auto()\n\n    Kind: KindEnum = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    # This is originally a string type in ilisMeta16.ili, but all actually\n    #  occuring values are floats, so we assume that this was done to\n    #  prevent limits of float definition in interlis 0.00 .. 1.00 since\n    #  we need a simple arbitrary float value. Thats why we cast the value to\n    #  float here silently\n    MaxOverlap: Optional[float] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    Multi: Optional[bool] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    CoordType_ref: Optional[Ref] = field(\n        default=None,\n        metadata={\"name\": \"CoordType\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n    )\n</code></pre> <code>CoordType_ref = field(default=None, metadata={'name': 'CoordType', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Kind = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>MaxOverlap = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Multi = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>KindEnum</code> <p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>class KindEnum(StrEnum):\n    Polyline = auto()\n    DirectedPolyline = auto()\n    Area = auto()\n</code></pre> <code>Area = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>DirectedPolyline = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Polyline = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Kind, MaxOverlap=None, Multi=None, CoordType_ref=None, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>MultiValue</code> <code>dataclass</code> <p>               Bases: <code>TypeRelatedType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass\nclass MultiValue(TypeRelatedType):\n\n    @dataclass\n    class _Multiplicity:\n        Multiplicity: MultiplicityElement = field(\n            default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n        )\n\n    Ordered: bool = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    Multiplicity: Optional[\"MultiValue._Multiplicity\"] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n</code></pre> <code>Multiplicity = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Ordered = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>_Multiplicity</code> <code>dataclass</code> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass\nclass _Multiplicity:\n    Multiplicity: MultiplicityElement = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n</code></pre> <code>Multiplicity = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Multiplicity=None)</code> <code>__init__(BaseType_ref, Ordered, Multiplicity=None, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>NumType</code> <code>dataclass</code> <p>               Bases: <code>DomainType</code>, <code>HasRef</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass(kw_only=True)\nclass NumType(DomainType, HasRef):\n    Min: Optional[str] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    Max: Optional[str] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    Circular: Optional[bool] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    Clockwise: Optional[bool] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    Unit_ref: Optional[Ref] = field(\n        default=None, metadata={\"name\": \"Unit\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n</code></pre> <code>Circular = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Clockwise = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Max = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Min = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Unit_ref = field(default=None, metadata={'name': 'Unit', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory, Min=None, Max=None, Circular=None, Clockwise=None, Unit_ref=None)</code> <code>TextType</code> <code>dataclass</code> <p>               Bases: <code>DomainType</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass\nclass TextType(DomainType):\n    class KindEnum(StrEnum):\n        MText = auto()\n        Text = auto()\n        Name = auto()\n        Uri = auto()\n\n    Kind: KindEnum = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n\n    MaxLength: Optional[int] = field(\n        default=None, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n</code></pre> <code>Kind = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>MaxLength = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>KindEnum</code> <p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>class KindEnum(StrEnum):\n    MText = auto()\n    Text = auto()\n    Name = auto()\n    Uri = auto()\n</code></pre> <code>MText = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Name = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Text = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Uri = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Kind, MaxLength=None, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code> <code>TypeRelatedType</code> <code>dataclass</code> <p>               Bases: <code>DomainType</code>, <code>HasRef</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/domain_type/domain_type.py</code> <pre><code>@dataclass\nclass TypeRelatedType(DomainType, HasRef):\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    BaseType_ref: Ref = field(\n        metadata={\"name\": \"BaseType\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n    )\n</code></pre> <code>BaseType_ref = field(metadata={'name': 'BaseType', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(BaseType_ref, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None, Mandatory)</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type.expression","title":"<code>expression</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type.expression.expression","title":"<code>expression</code>","text":"<code>CompoundExpr</code> <code>dataclass</code> <p>               Bases: <code>Expression</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/expression.py</code> <pre><code>@dataclass\nclass CompoundExpr(Expression):\n    class OperationEnum(StrEnum):\n        Implication = \"Implication\"  # 2.4!\n        And = \"And\"\n        Or = \"Or\"\n        Mult = \"Mult\"\n        Div = \"Div\"\n        Relation_Equal = \"Relation.Equal\"\n        Relation_NotEqual = \"Relation.NotEqual\"\n        Relation_LessOrEqual = \"Relation.LessOrEqual\"\n        Relation_GreaterOrEqual = \"Relation.GreaterOrEqual\"\n        Relation_Less = \"Relation.Less\"\n        Relation_Greater = \"Relation.Greater\"\n\n    Operation: Optional[OperationEnum] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n</code></pre> <code>Operation = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>OperationEnum</code> <p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/expression.py</code> <pre><code>class OperationEnum(StrEnum):\n    Implication = \"Implication\"  # 2.4!\n    And = \"And\"\n    Or = \"Or\"\n    Mult = \"Mult\"\n    Div = \"Div\"\n    Relation_Equal = \"Relation.Equal\"\n    Relation_NotEqual = \"Relation.NotEqual\"\n    Relation_LessOrEqual = \"Relation.LessOrEqual\"\n    Relation_GreaterOrEqual = \"Relation.GreaterOrEqual\"\n    Relation_Less = \"Relation.Less\"\n    Relation_Greater = \"Relation.Greater\"\n</code></pre> <code>And = 'And'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Div = 'Div'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Implication = 'Implication'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Mult = 'Mult'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Or = 'Or'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Relation_Equal = 'Relation.Equal'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Relation_Greater = 'Relation.Greater'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Relation_GreaterOrEqual = 'Relation.GreaterOrEqual'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Relation_Less = 'Relation.Less'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Relation_LessOrEqual = 'Relation.LessOrEqual'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Relation_NotEqual = 'Relation.NotEqual'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Operation=None)</code> <code>Expression</code> <code>dataclass</code> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/expression.py</code> <pre><code>@dataclass(kw_only=True)\nclass Expression:\n    pass\n</code></pre> <code>__init__()</code> <code>UnaryExpr</code> <code>dataclass</code> <p>               Bases: <code>Expression</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/expression.py</code> <pre><code>@dataclass\nclass UnaryExpr(Expression):\n    class OperationEnum(StrEnum):\n        Not = auto()\n        Defined = auto()\n\n    Operation: OperationEnum = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n    SubExpressions: List[Expression] = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n</code></pre> <code>Operation = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>SubExpressions = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>OperationEnum</code> <p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/expression.py</code> <pre><code>class OperationEnum(StrEnum):\n    Not = auto()\n    Defined = auto()\n</code></pre> <code>Defined = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Not = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Operation, SubExpressions)</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type.expression.factor","title":"<code>factor</code>","text":"<code>factor</code> <code>Constant</code> <code>dataclass</code> <p>               Bases: <code>Factor</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/factor/factor.py</code> <pre><code>@dataclass\nclass Constant(Factor):\n    class TypeKind(StrEnum):\n        Undefined = \"Undefined\"\n        Numeric = \"Numeric\"\n        Text = \"Text\"\n        Enumeration = \"Enumeration\"\n\n    Value: str\n    Type: TypeKind\n</code></pre> <code>Type</code> <code>instance-attribute</code> <code>Value</code> <code>instance-attribute</code> <code>TypeKind</code> <p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/factor/factor.py</code> <pre><code>class TypeKind(StrEnum):\n    Undefined = \"Undefined\"\n    Numeric = \"Numeric\"\n    Text = \"Text\"\n    Enumeration = \"Enumeration\"\n</code></pre> <code>Enumeration = 'Enumeration'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Numeric = 'Numeric'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Text = 'Text'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Undefined = 'Undefined'</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Value, Type)</code> <code>Factor</code> <code>dataclass</code> <p>               Bases: <code>Expression</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/factor/factor.py</code> <pre><code>@dataclass(kw_only=True)\nclass Factor(Expression):\n    pass\n</code></pre> <code>__init__()</code> <code>PathOrInspFactor</code> <code>dataclass</code> <p>               Bases: <code>Factor</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/factor/factor.py</code> <pre><code>@dataclass\nclass PathOrInspFactor(Factor):\n\n    PathEls: PathElsElement\n</code></pre> <code>PathEls</code> <code>instance-attribute</code> <code>__init__(PathEls)</code> <code>UnitFunction</code> <code>dataclass</code> <p>               Bases: <code>Factor</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/factor/factor.py</code> <pre><code>@dataclass\nclass UnitFunction(Factor):\n\n    Explanation: str\n</code></pre> <code>Explanation</code> <code>instance-attribute</code> <code>__init__(Explanation)</code> <code>UnitRef</code> <code>dataclass</code> <p>               Bases: <code>Factor</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/expression/factor/factor.py</code> <pre><code>@dataclass\nclass UnitRef(Factor):\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    Unit_ref: Ref = field(\n        metadata={\"name\": \"Unit\"},\n    )\n</code></pre> <code>Unit_ref = field(metadata={'name': 'Unit'})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Unit_ref)</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type.type_class","title":"<code>type_class</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type.type_class.BaseClass","title":"<code>BaseClass</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HasRef</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/type_class.py</code> <pre><code>@dataclass\nclass BaseClass(HasRef):\n\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    CRT_ref: Ref = field(metadata={\"name\": \"CRT\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    BaseClass_ref: Ref = field(\n        metadata={\"name\": \"BaseClass\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n</code></pre> <code>BaseClass_ref = field(metadata={'name': 'BaseClass', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>CRT_ref = field(metadata={'name': 'CRT', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(CRT_ref, BaseClass_ref)</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type.type_class.Class","title":"<code>Class</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Type</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/type_class.py</code> <pre><code>@dataclass\nclass Class(Type):\n\n    class KindEnum(StrEnum):\n        Structure = auto()\n        Class = auto()\n        View = auto()\n        Association = auto()\n\n    @dataclass\n    class _Multiplicity:\n        multiplicity: Optional[MultiplicityElement] = field(\n            default=None,\n            metadata={\"name\": \"LTParent\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n        )\n\n    Kind: KindEnum = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    EmbeddedRoleTransfer: bool = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    ili1OptionalTable: Optional[bool] = field(\n        default=None,\n        metadata={\n            \"type\": \"Attribute\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    Multiplicity: Optional[\"Class._Multiplicity\"] = field(\n        default=None,\n        metadata={\n            \"type\": \"Attribute\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    Oid_ref: Optional[Ref] = field(\n        default=None, metadata={\"name\": \"Oid\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n</code></pre> <code>EmbeddedRoleTransfer = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Kind = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Multiplicity = field(default=None, metadata={'type': 'Attribute', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Oid_ref = field(default=None, metadata={'name': 'Oid', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>ili1OptionalTable = field(default=None, metadata={'type': 'Attribute', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>KindEnum</code> <p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/type_class.py</code> <pre><code>class KindEnum(StrEnum):\n    Structure = auto()\n    Class = auto()\n    View = auto()\n    Association = auto()\n</code></pre> <code>Association = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Class = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>Structure = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>View = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>_Multiplicity</code> <code>dataclass</code> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/type_class.py</code> <pre><code>@dataclass\nclass _Multiplicity:\n    multiplicity: Optional[MultiplicityElement] = field(\n        default=None,\n        metadata={\"name\": \"LTParent\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n    )\n</code></pre> <code>multiplicity = field(default=None, metadata={'name': 'LTParent', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(multiplicity=None)</code> <code>__init__(Kind, EmbeddedRoleTransfer, ili1OptionalTable=None, Multiplicity=None, Oid_ref=None, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None)</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.extendable_me.type.type_class.Type","title":"<code>Type</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ExtendableMe</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/extendable_me/type/type_class.py</code> <pre><code>@dataclass(kw_only=True)\nclass Type(ExtendableMe):\n    LTParent_ref: Optional[Ref] = field(\n        default=None,\n        metadata={\"name\": \"LTParent\", \"namespace\": imd_namespace_map[\"IlisMeta16\"]},\n    )\n</code></pre> <code>LTParent_ref = field(default=None, metadata={'name': 'LTParent', 'namespace': imd_namespace_map['IlisMeta16']})</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None, Abstract, Final, Super_ref=None, Generic=None, LTParent_ref=None)</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.line_form","title":"<code>line_form</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.line_form.LineForm","title":"<code>LineForm</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MetaElement</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/line_form.py</code> <pre><code>@dataclass\nclass LineForm(MetaElement):\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    Structure_ref: Optional[Ref] = field(\n        metadata={\n            \"name\": \"Structure\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.line_form.LineForm.Structure_ref","title":"<code>Structure_ref = field(metadata={'name': 'Structure', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.line_form.LineForm.__init__","title":"<code>__init__(Structure_ref, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.line_form.LinesForm","title":"<code>LinesForm</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HasRef</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/line_form.py</code> <pre><code>@dataclass\nclass LinesForm(HasRef):\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    LineType_ref: Ref = field(\n        metadata={\n            \"name\": \"LineType\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    LineForm_ref: Ref = field(\n        metadata={\n            \"name\": \"LineForm\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.line_form.LinesForm.LineForm_ref","title":"<code>LineForm_ref = field(metadata={'name': 'LineForm', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.line_form.LinesForm.LineType_ref","title":"<code>LineType_ref = field(metadata={'name': 'LineType', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.line_form.LinesForm.__init__","title":"<code>__init__(LineType_ref, LineForm_ref)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element","title":"<code>meta_element</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element.MetaElement","title":"<code>MetaElement</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HasRef</code>, <code>AbstractElement</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/meta_element.py</code> <pre><code>@dataclass(kw_only=True)\nclass MetaElement(HasRef, AbstractElement):\n    Name: str = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n    tid: str = field(metadata={\"type\": \"Attribute\", \"namespace\": imd_namespace_map[\"ili\"]})\n    Documentation: Optional[List[\"MetaElement._Documentation\"]] = field(\n        default_factory=list,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    MetaAttribute: Optional[List[MetaAttributeElement]] = field(\n        default_factory=list,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    ElementInPackage_ref: Optional[Ref] = field(\n        default=None,\n        metadata={\"name\": \"ElementInPackage\"},\n    )\n\n    @dataclass\n    class _Documentation:\n        DocText: DocTextElement = field(\n            metadata={\n                \"name\": \"DocText\",\n                \"type\": \"Element\",\n                \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n            },\n        )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element.MetaElement.Documentation","title":"<code>Documentation = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element.MetaElement.ElementInPackage_ref","title":"<code>ElementInPackage_ref = field(default=None, metadata={'name': 'ElementInPackage'})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element.MetaElement.MetaAttribute","title":"<code>MetaAttribute = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element.MetaElement.Name","title":"<code>Name = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element.MetaElement.tid","title":"<code>tid = field(metadata={'type': 'Attribute', 'namespace': imd_namespace_map['ili']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element.MetaElement._Documentation","title":"<code>_Documentation</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/meta_element.py</code> <pre><code>@dataclass\nclass _Documentation:\n    DocText: DocTextElement = field(\n        metadata={\n            \"name\": \"DocText\",\n            \"type\": \"Element\",\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element.MetaElement._Documentation.DocText","title":"<code>DocText = field(metadata={'name': 'DocText', 'type': 'Element', 'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element.MetaElement._Documentation.__init__","title":"<code>__init__(DocText)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.meta_element.MetaElement.__init__","title":"<code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data","title":"<code>model_data</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType","title":"<code>ModelDataType</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/model_data.py</code> <pre><code>@dataclass\nclass ModelDataType:\n\n    bid: str = field(metadata={\"type\": \"Attribute\", \"namespace\": imd_namespace_map[\"ili\"]})\n    Model: \"Model\" = field(metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]})\n    # TODO: Keep an eye on requested list length (as of meta model docs list of sub_model has to\n    #  be at least 1)\n    SubModel: List[\"SubModel\"] = field(default_factory=list)\n    DataUnit: List[\"DataUnit\"] = None\n    MetaAttribute: Optional[List[MetaAttributeElement]] = field(default_factory=list)\n    consistency: Optional[str] = field(\n        default=None,\n        metadata={\n            \"type\": \"Attribute\",\n            \"namespace\": imd_namespace_map[\"ili\"],\n        },\n    )\n    Class: Optional[List[\"Class\"]] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    AttrOrParam: List[\"AttrOrParam\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    TextType: Optional[List[\"TextType\"]] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    EnumNode: List[\"EnumNode\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    EnumType: List[\"EnumType\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    NumType: Optional[List[\"NumType\"]] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    AxisSpec: List[\"AxisSpec\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    CoordType: List[\"CoordType\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    BaseClass: List[\"BaseClass\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    ObjectType: List[\"ObjectType\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    ClassRefType: List[\"ClassRefType\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    MultiValue: Optional[List[\"MultiValue\"]] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    BooleanType: List[\"BooleanType\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    FormattedType: List[\"FormattedType\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    LinesForm: List[\"LinesForm\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    LineType: List[\"LineType\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    LineForm: List[\"LineForm\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    Role: List[\"Role\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    SimpleConstraint: List[\"SimpleConstraint\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    ReferenceType: List[\"ReferenceType\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    BlackboxType: Optional[List[\"BlackboxType\"]] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n    Unit: List[\"Unit\"] = field(\n        default_factory=list, metadata={\"namespace\": imd_namespace_map[\"IlisMeta16\"]}\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.AttrOrParam","title":"<code>AttrOrParam = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.AxisSpec","title":"<code>AxisSpec = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.BaseClass","title":"<code>BaseClass = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.BlackboxType","title":"<code>BlackboxType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.BooleanType","title":"<code>BooleanType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.Class","title":"<code>Class = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.ClassRefType","title":"<code>ClassRefType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.CoordType","title":"<code>CoordType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.DataUnit","title":"<code>DataUnit = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.EnumNode","title":"<code>EnumNode = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.EnumType","title":"<code>EnumType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.FormattedType","title":"<code>FormattedType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.LineForm","title":"<code>LineForm = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.LineType","title":"<code>LineType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.LinesForm","title":"<code>LinesForm = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.MetaAttribute","title":"<code>MetaAttribute = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.Model","title":"<code>Model = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.MultiValue","title":"<code>MultiValue = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.NumType","title":"<code>NumType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.ObjectType","title":"<code>ObjectType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.ReferenceType","title":"<code>ReferenceType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.Role","title":"<code>Role = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.SimpleConstraint","title":"<code>SimpleConstraint = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.SubModel","title":"<code>SubModel = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.TextType","title":"<code>TextType = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.Unit","title":"<code>Unit = field(default_factory=list, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.bid","title":"<code>bid = field(metadata={'type': 'Attribute', 'namespace': imd_namespace_map['ili']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.consistency","title":"<code>consistency = field(default=None, metadata={'type': 'Attribute', 'namespace': imd_namespace_map['ili']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.model_data.ModelDataType.__init__","title":"<code>__init__(bid, Model, SubModel=list(), DataUnit=None, MetaAttribute=list(), consistency=None, Class=list(), AttrOrParam=list(), TextType=list(), EnumNode=list(), EnumType=list(), NumType=list(), AxisSpec=list(), CoordType=list(), BaseClass=list(), ObjectType=list(), ClassRefType=list(), MultiValue=list(), BooleanType=list(), FormattedType=list(), LinesForm=list(), LineType=list(), LineForm=list(), Role=list(), SimpleConstraint=list(), ReferenceType=list(), BlackboxType=list(), Unit=list())</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package","title":"<code>package</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package","title":"<code>package</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model","title":"<code>Model</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Package</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/package/package.py</code> <pre><code>@dataclass\nclass Model(Package):\n    class KindEnum(StrEnum):\n        NormalM = auto()\n        TypeM = auto()\n        RefSystemM = auto()\n        SymbologyM = auto()\n\n    iliVersion: str = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n    Kind: KindEnum = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n    Contracted: Optional[bool] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    Language: Optional[str] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    At: Optional[str] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    Version: Optional[str] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    NoIncrementalTransfer: Optional[bool] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    CharSetIANAName: Optional[str] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    xmlns: Optional[str] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    ili1Transfername: Optional[str] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    ili1Format: Optional[\"Model._Ili1Format\"] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n\n    @dataclass\n    class _Ili1Format:\n        Ili1Format: Optional[Ili1FormatElement] = None\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.At","title":"<code>At = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.CharSetIANAName","title":"<code>CharSetIANAName = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.Contracted","title":"<code>Contracted = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.Kind","title":"<code>Kind = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.Language","title":"<code>Language = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.NoIncrementalTransfer","title":"<code>NoIncrementalTransfer = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.Version","title":"<code>Version = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.ili1Format","title":"<code>ili1Format = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.ili1Transfername","title":"<code>ili1Transfername = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.iliVersion","title":"<code>iliVersion = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.xmlns","title":"<code>xmlns = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.KindEnum","title":"<code>KindEnum</code>","text":"<p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/package/package.py</code> <pre><code>class KindEnum(StrEnum):\n    NormalM = auto()\n    TypeM = auto()\n    RefSystemM = auto()\n    SymbologyM = auto()\n</code></pre> <code>NormalM = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>RefSystemM = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>SymbologyM = auto()</code> <code>class-attribute</code> <code>instance-attribute</code> <code>TypeM = auto()</code> <code>class-attribute</code> <code>instance-attribute</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model._Ili1Format","title":"<code>_Ili1Format</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/package/package.py</code> <pre><code>@dataclass\nclass _Ili1Format:\n    Ili1Format: Optional[Ili1FormatElement] = None\n</code></pre> <code>Ili1Format = None</code> <code>class-attribute</code> <code>instance-attribute</code> <code>__init__(Ili1Format=None)</code>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Model.__init__","title":"<code>__init__(iliVersion, Kind, Contracted=None, Language=None, At=None, Version=None, NoIncrementalTransfer=None, CharSetIANAName=None, xmlns=None, ili1Transfername=None, ili1Format=None, *, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Package","title":"<code>Package</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MetaElement</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/package/package.py</code> <pre><code>@dataclass(kw_only=True)\nclass Package(MetaElement):\n    pass\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.Package.__init__","title":"<code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.SubModel","title":"<code>SubModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Package</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/package/package.py</code> <pre><code>@dataclass\nclass SubModel(Package):\n    pass\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.package.package.SubModel.__init__","title":"<code>__init__(*, Name, tid, Documentation=list(), MetaAttribute=list(), ElementInPackage_ref=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements","title":"<code>path_elements</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement","title":"<code>PathElElement</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HasRef</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/path_elements.py</code> <pre><code>@dataclass\nclass PathElElement(HasRef):\n    # TODO: MANDATORY CONSTRAINT (Kind &gt;= #ReferenceAttr) == DEFINED(Ref);\n    class KindEnum(StrEnum):\n        This = auto()\n        ThisArea = auto()\n        ThatArea = auto()\n        Parent = auto()\n        ReferenceAttr = auto()\n        AssocPath = auto()\n        Role = auto()\n        ViewBase = auto()\n        Attribute = auto()\n        MetaObject = auto()\n\n    Kind: KindEnum\n    NumIndex: Optional[int] = None\n    # use the metadata.name to fetch the element from XML but store it\n    #   as `*_ref` instance variable to resolve soft reference to actual object\n    Ref_ref: Optional[Ref] = field(\n        default=None,\n        metadata={\"name\": \"Ref\"},\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.Kind","title":"<code>Kind</code>  <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.NumIndex","title":"<code>NumIndex = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.Ref_ref","title":"<code>Ref_ref = field(default=None, metadata={'name': 'Ref'})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum","title":"<code>KindEnum</code>","text":"<p>               Bases: <code>StrEnum</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/path_elements.py</code> <pre><code>class KindEnum(StrEnum):\n    This = auto()\n    ThisArea = auto()\n    ThatArea = auto()\n    Parent = auto()\n    ReferenceAttr = auto()\n    AssocPath = auto()\n    Role = auto()\n    ViewBase = auto()\n    Attribute = auto()\n    MetaObject = auto()\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum.AssocPath","title":"<code>AssocPath = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum.Attribute","title":"<code>Attribute = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum.MetaObject","title":"<code>MetaObject = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum.Parent","title":"<code>Parent = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum.ReferenceAttr","title":"<code>ReferenceAttr = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum.Role","title":"<code>Role = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum.ThatArea","title":"<code>ThatArea = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum.This","title":"<code>This = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum.ThisArea","title":"<code>ThisArea = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.KindEnum.ViewBase","title":"<code>ViewBase = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElElement.__init__","title":"<code>__init__(Kind, NumIndex=None, Ref_ref=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElsElement","title":"<code>PathElsElement</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/path_elements.py</code> <pre><code>@dataclass\nclass PathElsElement:\n    PathEl: List[PathElElement] = field(default_factory=list)\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElsElement.PathEl","title":"<code>PathEl = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathElsElement.__init__","title":"<code>__init__(PathEl=list())</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathOrInspFactorElement","title":"<code>PathOrInspFactorElement</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/path_elements.py</code> <pre><code>@dataclass\nclass PathOrInspFactorElement:\n    PathOrInspFactor: \"PathOrInspFactor\" = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathOrInspFactorElement.PathOrInspFactor","title":"<code>PathOrInspFactor = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.path_elements.PathOrInspFactorElement.__init__","title":"<code>__init__(PathOrInspFactor)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.references","title":"<code>references</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.references.log","title":"<code>log = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.references.HasRef","title":"<code>HasRef</code>","text":"<p>Abstract base class which is used to implement decent behaviour on desired subclasses.</p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/references.py</code> <pre><code>class HasRef:\n    \"\"\"\n    Abstract base class which is used to implement decent behaviour on desired subclasses.\n    \"\"\"\n\n    def resolve_refs(self, index: dict):\n        \"\"\"\n        References the actual object based on the unique identifier in the index. It is based currently\n        on a naming pattern. The attribute to be referenced has to be of type `Ref` and its name has to\n        end with *_ref*. Lets assume the attribute name is *Type_ref*. This method then installs a new\n        runtime attribute *Type* at `self`. In addition it installs a new runtime attribute at the referenced\n        object in our example that would be *Type_backref*. If this attribute does not exists already.\n        This is currently always a list which is filled with the back referenced objects.\n\n        TODO: handle multilevel references (currently we go only one level deep)\n        TODO: handle multiplicity m:n, 1:1, 1:n, etc\n\n        Args:\n            index: The index containing all potential referencable objects.\n        \"\"\"\n        for attribute_name in self.__dir__():\n            if isinstance(getattr(self, attribute_name), Ref):\n                reference = getattr(self, attribute_name).ref\n                if not index.get(reference, False):\n                    log.info(\n                        f\"Element with tid &lt;{reference}&gt; was not found in index. It is highly possible that it is not implemented yet\"\n                    )\n                else:\n                    referenced_element = index[reference]\n                    new_attribute_name = attribute_name.replace(\"_ref\", \"\")\n                    setattr(self, new_attribute_name, referenced_element)\n                    backref_name = f\"{new_attribute_name}_backref\"\n                    if not hasattr(referenced_element, backref_name):\n                        setattr(referenced_element, backref_name, [])\n                    getattr(referenced_element, backref_name).append(self)\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.references.HasRef.resolve_refs","title":"<code>resolve_refs(index)</code>","text":"<p>References the actual object based on the unique identifier in the index. It is based currently on a naming pattern. The attribute to be referenced has to be of type <code>Ref</code> and its name has to end with _ref. Lets assume the attribute name is Type_ref. This method then installs a new runtime attribute Type at <code>self</code>. In addition it installs a new runtime attribute at the referenced object in our example that would be Type_backref. If this attribute does not exists already. This is currently always a list which is filled with the back referenced objects.</p> <p>TODO: handle multilevel references (currently we go only one level deep) TODO: handle multiplicity m:n, 1:1, 1:n, etc</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>dict</code> <p>The index containing all potential referencable objects.</p> required Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/references.py</code> <pre><code>def resolve_refs(self, index: dict):\n    \"\"\"\n    References the actual object based on the unique identifier in the index. It is based currently\n    on a naming pattern. The attribute to be referenced has to be of type `Ref` and its name has to\n    end with *_ref*. Lets assume the attribute name is *Type_ref*. This method then installs a new\n    runtime attribute *Type* at `self`. In addition it installs a new runtime attribute at the referenced\n    object in our example that would be *Type_backref*. If this attribute does not exists already.\n    This is currently always a list which is filled with the back referenced objects.\n\n    TODO: handle multilevel references (currently we go only one level deep)\n    TODO: handle multiplicity m:n, 1:1, 1:n, etc\n\n    Args:\n        index: The index containing all potential referencable objects.\n    \"\"\"\n    for attribute_name in self.__dir__():\n        if isinstance(getattr(self, attribute_name), Ref):\n            reference = getattr(self, attribute_name).ref\n            if not index.get(reference, False):\n                log.info(\n                    f\"Element with tid &lt;{reference}&gt; was not found in index. It is highly possible that it is not implemented yet\"\n                )\n            else:\n                referenced_element = index[reference]\n                new_attribute_name = attribute_name.replace(\"_ref\", \"\")\n                setattr(self, new_attribute_name, referenced_element)\n                backref_name = f\"{new_attribute_name}_backref\"\n                if not hasattr(referenced_element, backref_name):\n                    setattr(referenced_element, backref_name, [])\n                getattr(referenced_element, backref_name).append(self)\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.references.OrderedRef","title":"<code>OrderedRef</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Ref</code></p> Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/references.py</code> <pre><code>@dataclass\nclass OrderedRef(Ref):\n    order_pos: str = field(metadata={\"type\": \"Attribute\", \"namespace\": imd_namespace_map[\"ili\"]})\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.references.OrderedRef.order_pos","title":"<code>order_pos = field(metadata={'type': 'Attribute', 'namespace': imd_namespace_map['ili']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.references.OrderedRef.__init__","title":"<code>__init__(ref, order_pos)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.references.Ref","title":"<code>Ref</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/references.py</code> <pre><code>@dataclass\nclass Ref:\n\n    ref: str = field(metadata={\"type\": \"Attribute\", \"namespace\": imd_namespace_map[\"ili\"]})\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.references.Ref.ref","title":"<code>ref = field(metadata={'type': 'Attribute', 'namespace': imd_namespace_map['ili']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.references.Ref.__init__","title":"<code>__init__(ref)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements","title":"<code>serialization_elements</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.CompoundExprElement","title":"<code>CompoundExprElement</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/serialization_elements.py</code> <pre><code>@dataclass\nclass CompoundExprElement:\n    CompoundExpr: \"CompoundExpr\" = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    UnaryExpression: \"UnaryExpr\" = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.CompoundExprElement.CompoundExpr","title":"<code>CompoundExpr = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.CompoundExprElement.UnaryExpression","title":"<code>UnaryExpression = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.CompoundExprElement.__init__","title":"<code>__init__(CompoundExpr=None, UnaryExpression=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.ConstantElement","title":"<code>ConstantElement</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/serialization_elements.py</code> <pre><code>@dataclass\nclass ConstantElement:\n    Constant: \"Constant\" = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.ConstantElement.Constant","title":"<code>Constant = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.ConstantElement.__init__","title":"<code>__init__(Constant)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.MultiplicityElement","title":"<code>MultiplicityElement</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/serialization_elements.py</code> <pre><code>@dataclass\nclass MultiplicityElement:\n\n    # TODO: *Optional* seems to be wrong regarding to ilismeta model\n    Min: Optional[int] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n    Max: Optional[int] = field(\n        default=None,\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        },\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.MultiplicityElement.Max","title":"<code>Max = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.MultiplicityElement.Min","title":"<code>Min = field(default=None, metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.MultiplicityElement.__init__","title":"<code>__init__(Min=None, Max=None)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.UnaryExprElement","title":"<code>UnaryExprElement</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/serialization_elements.py</code> <pre><code>@dataclass\nclass UnaryExprElement:\n    UnaryExpr: \"UnaryExpr\" = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.UnaryExprElement.UnaryExpr","title":"<code>UnaryExpr = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.UnaryExprElement.__init__","title":"<code>__init__(UnaryExpr)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.UnitFunctionElement","title":"<code>UnitFunctionElement</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/serialization_elements.py</code> <pre><code>@dataclass\nclass UnitFunctionElement:\n    UnitFunction: \"UnitFunction\" = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.UnitFunctionElement.UnitFunction","title":"<code>UnitFunction = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.UnitFunctionElement.__init__","title":"<code>__init__(UnitFunction)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.UnitRefElement","title":"<code>UnitRefElement</code>  <code>dataclass</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/ili2py/interfaces/interlis/interlis_24/ilismeta16/model_data/serialization_elements.py</code> <pre><code>@dataclass\nclass UnitRefElement:\n    UnitRef: \"UnitRef\" = field(\n        metadata={\n            \"namespace\": imd_namespace_map[\"IlisMeta16\"],\n        }\n    )\n</code></pre>"},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.UnitRefElement.UnitRef","title":"<code>UnitRef = field(metadata={'namespace': imd_namespace_map['IlisMeta16']})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_data.serialization_elements.UnitRefElement.__init__","title":"<code>__init__(UnitRef)</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.model_translation","title":"<code>model_translation</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.shared","title":"<code>shared</code>","text":""},{"location":"code/ilismeta16/#ili2py.interfaces.interlis.interlis_24.ilismeta16.shared.imd_namespace_map","title":"<code>imd_namespace_map = dict(namespace_map)</code>  <code>module-attribute</code>","text":""},{"location":"dev_guide/python_classes/","title":"Python Classes usage","text":"<p>The following section will guide you through some general usage of the python library by example.</p> <p>It is based on the example given in the start section - the <code>OeREBKRMtrsfr_V2_0</code> model. If not already done, you should head over and first create the python classes for that model as described.</p> <p>Info</p> <p>The following examples preassume you have called you library ili2py_interface and you have a python script next to that resulting folder like:</p> <p></p> <p>Tip</p> <p>All following examples assume you are in a command line session in the root of the project as shown above. After each change in the script you need to execute the script with <code>python demo.py</code></p>"},{"location":"dev_guide/python_classes/#enumerations","title":"Enumerations","text":"<p>As described in the user guide enumeration are stored as native python enums. But how you access them?</p> <p>Add that to your python script. </p><pre><code>from ili2py_interface.OeREBKRM_V2_0 import RechtsStatus\nprint(list(RechtsStatus))\n</code></pre><p></p> <p>The output should look like: <code>[&lt;RechtsStatus.INKRAFT: 'inKraft'&gt;, &lt;RechtsStatus.AENDERUNGMITVORWIRKUNG: 'AenderungMitVorwirkung'&gt;, &lt;RechtsStatus.AENDERUNGOHNEVORWIRKUNG: 'AenderungOhneVorwirkung'&gt;]</code></p> <p>So you can see that the information of the value list is there.</p> <p>How to access the content?</p> <p>Alter your script to. </p><pre><code>from ili2py_interface.OeREBKRM_V2_0 import RechtsStatus\nprint(list(RechtsStatus.INKRAFT.value))\n</code></pre><p></p> <p>The output should look like: <code>\u00ecnKraft</code></p> <p>This is how you access the value lists defined originally in the interlis model. You find them by following the linked types in the IDE of your choice using go-to-definition features.</p>"},{"location":"dev_guide/python_classes/#access-metainformation","title":"Access metainformation","text":"<p>Each class and each field in the created library has meta information stored.</p> <p>How can we access it?</p> <pre><code>from ili2py_interface.OeREBKRMtrsfr_V2_0.Transferstruktur import Eigentumsbeschraenkung\nfrom dataclasses import fields\nprint(fields(Eigentumsbeschraenkung)[2])\n</code></pre> <p>The output should look like: </p><pre><code>Field(name='publiziertAb',type='str | None',default=None,default_factory=&lt;dataclasses._MISSING_TYPE object at 0x7f0439902f90&gt;,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({'type': 'Element', 'namespace': 'http://www.interlis.ch/INTERLIS2.3', 'interlis': {'oid': 'OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung.publiziertAb', 'meta_attributes': {}, 'type_restrictions': {'mandatory': True, 'kind': None, 'format': '\"Year\"-\"Month\"-\"Day\"', 'unit': None, 'ref_sys': None, 'clockwise': None, 'circular': None, 'abstract': False, 'final': False, 'generic': False, 'super': 'OeREBKRM_V2_0.Datum', 'type_related_type': False, 'multiplicity': {'min': 1, 'max': 1}, 'struct': 'INTERLIS.GregorianDate', 'min': '1848-1-1', 'max': '2100-12-31'}}, 'geometric': {'is_geometric': False, 'multi': False, 'point_like': False, 'line_like': False, 'polygon_like': False}}),kw_only=False,_field_type=_FIELD)\n</code></pre><p></p> <p>Fields of dataclasses can be accessed from a class or also from an instance. This is really handy since we also can access this information at runtime on instantiated objects. We use the fields method from the <code>dataclasses</code> library for that.</p> <p>In the example above we access the 3rd field of the class <code>Eigentumsbeschraenkung</code> which is the <code>publiziertAb</code> attribute.</p> <p>On that we now can access the dataclass native <code>metadata</code> attribute and in that the interlis specific information.</p> <p>Alter your script:</p> <pre><code>from ili2py_interface.OeREBKRMtrsfr_V2_0.Transferstruktur import Eigentumsbeschraenkung\nfrom dataclasses import fields\nprint(fields(Eigentumsbeschraenkung)[2].metadata['interlis']['type_restrictions'])\n</code></pre> <p>This gives:</p> <pre><code>{'mandatory': True, 'kind': None, 'format': '\"Year\"-\"Month\"-\"Day\"', 'unit': None, 'ref_sys': None, 'clockwise': None, 'circular': None, 'abstract': False, 'final': False, 'generic': False, 'super': 'OeREBKRM_V2_0.Datum', 'type_related_type': False, 'multiplicity': {'min': 1, 'max': 1}, 'struct': 'INTERLIS.GregorianDate', 'min': '1848-1-1', 'max': '2100-12-31'}\n</code></pre> <p>To access the metadata of the object instance itself:</p> <pre><code>print(Eigentumsbeschraenkung().metadata)\n</code></pre>"},{"location":"documents/overview/","title":"Overview","text":"<p>In this section are documents stored which are relevant for the context and understanding of ili2py.</p>"},{"location":"documents/report/report/","title":"Report (Nov '23)","text":""},{"location":"documents/report/report/#python-bindings-fur-interlis","title":"Python Bindings f\u00fcr INTERLIS","text":""},{"location":"documents/report/report/#zusammenfassung","title":"Zusammenfassung","text":"<p>Vorliegender POC skizziert die M\u00f6glichkeiten anhand von INTERLIS-Modellen Pythonstrukturen abzuleiten. Diese Strukturen sollen genutzt werden um nativ in der Programmiersprache Python Applikationen aufbauen zu k\u00f6nnen. Vordringlichstes Ziel ist die Verbreiterung der Anwenderbasis. Python ist heute eine der am weitesten verbreiteten Programmiersprachen und besonders im Opensource-Umfeld nicht wegzudenken.</p> <p>Dieser POC nutzt bewusst bereits vorhandene Mechanismen mit denen INTERLIS vom abstrakten Datenmodell in die praktische Welt der Programmierung zu heben. Das Metamodell. Es wurde genau zu diesem Zwecke geschaffen. So ist der Ausgangspunkt f\u00fcr alle hier gezeigten Beispiele immer das Metamodell (imd) des jeweiligen INTERLIS-Modells (ili). Die Erstellung des jeweiligen Metamodells \u00fcbernimmt in diesem POC die Software <code>\u00ecli2c</code>.</p> <p>Der Ausgang dieses POCs ist positiv. Alle gew\u00fcnschten Anwendungsf\u00e4lle konnten belegt werden. Auf dieser Basis kann nun eine neuerliche Diskussion \u00fcber die weiteren Ziele gef\u00fchrt werden.</p> <p>Folgende Anwendungsf\u00e4lle wurden implementiert:</p> <ul> <li>beliebiges Metamodell lesen und dessen Definition als JSON ausgeben (mgl. Ziel: OPENAPI, JSON Schema Definition)</li> <li>beliebiges XTF seinem Modell nach lesen und dessen Inhalt als JSON ausgeben (mgl. Ziel: dynamisch erzeugte generische Reader, um XTF zu lesen)</li> <li>beliebiges Metamodell lesen und dessen Definition als Pyton-Code (dataclasses) ausgeben (mgl. Ziel: Validierung von Formularen, Editor-Syntax Highlighting + Autocomplete, Basisbibliothek f\u00fcr Fachapplikationen)</li> </ul>"},{"location":"documents/report/report/#einfuhrung","title":"Einf\u00fchrung","text":"<p>INTERLIS ist in der Schweiz eine der wichtigsten (und vom Bund vorgeschriebene) Modellierungssprache f\u00fcr viele digitale (Geo)Daten. An dieser Stelle sollen dem Leser die Details der Theorie erspart bleiben und einfach nur auf die umfangreichen Referenzhandb\u00fccher verwiesen werden.</p> <p>Wichtige Punkte zum Verst\u00e4ndnis dieses Konzepts werden hier kurz erl\u00e4utert. Es wird jedoch erwartet, dass eine gewisse Vorbildung zum Thema besteht. Auch wenn mit diesem Text kleinere praktische Elemente erl\u00e4utert werden geht es doch vorerst noch darum technisch, philosophisch auf einen Nenner mit dem Leser zu kommen. Es sollen wichtige technische Grundbegriffe beleuchtet werden.</p>"},{"location":"documents/report/report/#einordnung","title":"Einordnung","text":"<p>INTERLIS wird immer als einer unabh\u00e4ngigen Modellierungssprache, vorrangig f\u00fcr Geodaten, inzwischen aber auch dar\u00fcber hinaus gehandelt. Das ist korrekt. Die intuitive Sprache l\u00e4sst aber schnell vergessen, dass man sich in der digitalen Welt bewegt und das, was man Modellieren nennt, eigentlich Programmieren ist. Dem interessierten Leser sei an dieser Stelle das Studium der Programmiersprache Modula-2 ans Herz gelegt. Sie ist es die man schreibt, wenn man INTERLIS schreibt. Nat\u00fcrlich mit Erweiterungen, aber im Kern ist es Modula-2. Wir programmieren also wenn wir modellieren! Man k\u00f6nnte dieselben Resultate erreichen wenn man die Klassen und Assoziationen einfach in JAVA oder PYTHON schreiben w\u00fcrde. Bis auf ein Detail: INTERLIS bildet die Grundbausteine ab, die in jeder halbwegs modernen Programmiersprache heutzutage zu finden sind und ist deshalb universell. Das heisst, es l\u00e4sst sich ohne Probleme in Konstrukte der Wahlsprache \u00fcbersetzen. Und das ist eine der wichtigsten F\u00e4higkeiten von INTERLIS. Die, die wir nutzen wollen. Denn, wozu ein Datenmodell, wenn man keine Software daf\u00fcr hat?</p> <p>Wenn wir nun also beim Modellieren programmieren sollten wir unsere Werkzeuge, Arbeitsabl\u00e4ufe, Praktiken und Verwaltungsans\u00e4tze auch den Entwicklungen der Zeit ann\u00e4hern. Versionsverwaltung, Packagemangement, Releasemanagement, Codingsupport, automatische Generierung von Dokumentation, all das sind verglichen mit INTERLIS eher neuere aber nicht weniger wichtige Erfindungen in der IT.</p> <p>Man k\u00f6nnte nun sagen, INTERLIS sei reines Austauschformat. Also ein Vertrag zwischen Datenlieferant und Datenempf\u00e4nger, welcher in aller Tiefe den Inhalt definiert. Als solches wird es auch vorrangig genutzt. Allerdings hat die Praxis wie immer auch ihre eigenen Bl\u00fcten neben der Theorie getrieben und INTERLIS wird eben nicht nur mehr zur Definition im Datenaustausch genutzt, sondern auch zur Definition von Erfassungsmodellen, Darstellungsmodellen (Strukturen optimiert f\u00fcr das grafische Rendering der Daten) oder applikationszentrischen Modellen (z.B.: \u00d6REB). Schnell wird neben dem Anwendungsfall die Daten zu senden und zu empfangen, das bedeutet eigentlich Datenbankexport und Datenbankimport, auch eine Applikation mit Logik auf INTERLIS Strukturen aufgebaut die \u00fcber den urspr\u00fcnglichen Anwendungszeck hinausgehen. Werkzeuge wie die verschiednen \u00d6REB-Server Umsetzungen, Versuche Texteditoren mit Syntax-Highlighting und Autocompletion auszustatten oder auch Model Baker sind lebendige Beweise dieser These.</p>"},{"location":"documents/report/report/#software","title":"Software","text":"<p>Die folgenden Betrachtungen beziehen sich auf OpenSource Software. Sie sind nicht ausgrenzend oder abschliessend und orientieren sich an dem \u00d6kosystem welches dem Autor in seinem t\u00e4glichen Umgang mit dem Thema bekannt ist.</p> <p>Wovon reden wir also, wenn es um die Software geht? Heute gibt es neben diversen Fachschalen nur EINE Sammlung von Werkzeugen, die sich mit der generischen Nutzung von INTERLIS im Applikationsumfeld auseinandersetzt:</p> <p>Die Ilitools der Eisenhut Informatik AG</p> <p>Sie sind seit Jahren first-class-member der INTERLIS-Welt und k\u00f6nnen wohl als der Goldstandard hinsichtlich Umsetzung, Generik und dem Verst\u00e4ndnis der Materie gelten. Dies gilt nicht nur f\u00fcr JAVA sondern die Designentscheidungen welche hier getroffen wurden sind unabh\u00e4ngig von der Zielsprache als universell zu betrachten.</p>"},{"location":"documents/report/report/#funktionsuberblick-ilitools","title":"Funktions\u00fcberblick ilitools","text":"<p>Auf der Webseite werden diese Werkzeuge als Schnittstellen bezeichnet. Und das sind sie. Nicht mehr und nicht weniger. Wenn wir das Umfeld anschauen und es grob vereinfachen gruppieren sie alle sich um einen Kern. Dem Metamodell. Es ist die abstrakte Beschreibung der INTERLIS-Sprachelemente. Ihr Zweck ist die \u00dcbersetzung von .ili Dateien in die Sprache/Elemente des jeweiligen Zielsystems.</p> <pre><code>flowchart BT\n\n\n    interlis_model[\".ili\"]\n    meta_model[\"MetaModell\"]\n    pg[\"Postgres\"]\n    oracle[\"Oacle\"]\n    fme[\"FME\"]\n    uml[\"UML\"]\n    gpkg[\"GeoPackage\"]\n\n    interlis_model--&gt;meta_model\n    meta_model--&gt;pg\n    meta_model--&gt;oracle\n    meta_model--&gt;fme\n    meta_model--&gt;uml\n    meta_model--&gt;gpkg\n</code></pre> <p>Statt also f\u00fcr jedes Modell eigene Software schreiben zu m\u00fcssen, f\u00fchrt die Abfolge der Arbeitsschritte \u00fcber die generische Schicht ins Zielsystem. Das Kompilieren des .ili Modells in das Metamodell erfolgt durch JAVA und im Prozess innerhalb von JAVA Code. Der Nutzer merkt bei den ilitools davon nichts. Intern wird aber nach dem Bauplan des Metamodells ein ineinander verschachteltes Konstrukt aus (Java) Klassen, sozusagen Programmierung-on-the-fly, erzeugt. Dieses standardisierte Konstrukt wird dann innerhalb der jeweiligen spezifischen Auspr\u00e4gung (z.B.: ili2pg) genutzt um Operationen auszuf\u00fchren. In unserem Beispiel eben dann, um mittels SQL dem Modell entsprechende Datenbankstrukturen zu erstellen. Mittels INTERLIS Compiler (ili2c) kann der \"versteckte\" Schritt f\u00fcr den Nutzer \"sichtbar\" gemacht werden. Es wird eine .imd Datei erzeugt. Diese ist eigentlich eine INTERLIS Transferdatei, also ein XML und enth\u00e4lt den universellen Bauplan des kompilierten Modells.</p> <pre><code>flowchart LR\n\n\n    interlis_model[\".ili\"]\n    subgraph ili2c[\"INTERLIS Compiler\"]\n        parsing[\"parsen\"]\n        compile[\"kompilieren\"]\n        meta_model[\"MetaModell\"]\n    end\n    imd[\".imd\"]\n\n    interlis_model--&gt;parsing\n    parsing--&gt;compile\n    compile--&gt;meta_model\n    meta_model--&gt;imd\n</code></pre> <p>INTERLIS erm\u00f6glicht in einem Modell Elemente aus einem anderen Modell zu nutzen (IMPORTS). Dies ist ein wichtiger Baustein, der zum Erfolg des Systems beitr\u00e4gt. Diese Art Verkettung bedeutet aber, dass zum Kompilierungszeitpunkt die komplette Kette an Informationen zur Verf\u00fcgung stehen muss.</p> <pre><code>classDiagram\n    direction BT\n    class INTERLIS{\n        Basisdefinitionen\n    }\n    class Units{\n        m\n        km\n        ...\n    }\n    class AnwenderModell{\n        IMPORTS Units;\n    }\n    AnwenderModell --|&gt; Units : imports\n    Units --|&gt; INTERLIS : imports (implizit)\n</code></pre> <p>Dieser Punkt ist f\u00fcr die sp\u00e4teren Diskussionspunkte wichtig und aus diesem Grunde hier nur stark verk\u00fcrzt und fast schon unzul\u00e4ssig vereinfacht dargestellt. Die ilitools \u00fcbernehmen dies Aufgabe aber. So ist der Inhalt eines kompilierten Metamodells immer der Inhalt der kompletten Kette - Ein wichtiges Detail.</p>"},{"location":"documents/report/report/#flexibilitat","title":"Flexibilit\u00e4t","text":"<p>Aus Sicht eines JAVA-Entwicklers d\u00fcrften nun alle wichtigen Informationen klar sein. Ein neues Zielsystem bedeutet ein neues ili2XXX Werkzeug. Der Vielfalt sind keine Grenzen gesetzt. Solange wir uns im JAVA-Umfeld bewegen ist die Geschichte wahr. Und dar\u00fcber hinaus auch in die eine oder andere Richtung vielleicht auch noch weiter. Will man aber die domainspezifischen Informationen, die \u00fcblicherweise in einem INTERLIS-Modell stecken in anderen Programmiersprachen nutzen, wird es schnell d\u00fcnn. \u00dcber Umwege k\u00f6nnen wir diese Information transportieren. Klassisch w\u00e4re hier der Import von Modell und Daten in eine relationale Datenbank und aufbauend auf dieser dann die Extraktion der Modellinformationen. Doch halt. Wir haben hier einen Transformationsschritt, bei dem Informationen verloren gehen. Dar\u00fcber hinaus m\u00fcssen beim Wechsel vom Objektraum (INTERLIS-Modell) in den relationalen Raum (Datenbank) Kompromisse eingegangen werden. Dies verhindert, dass ein Programm welches seine Informationen aus der resultierenden Datenbank bezieht nicht die Wahrheit des urspr\u00fcnglichen Modells kennen kann. In der Praxis behilft man sich mit allerhand Feenstaub und das funktioniert auch meistens. Ein paar Metaattribute hier, ein bisschen Kommentarprogrammierung dort. Letzen Endes sind das aber alles teils spezifische L\u00f6sungen und nicht vom Charakter wie wir ihn von einem generischen Software-Ansatz erwarten. Flexibel und systemunabh\u00e4ngig sind wir aktuell im INTERLIS-Umfeld nur in der JAVA-Welt. Don't state the obvious. Egal ich tue es trotzdem. DAS IST EIN WIDERSPRUCH IN SICH!</p> <p>Nat\u00fcrlich k\u00f6nnen wir aus JAVA heraus allerhand Spielereien machen. Wir k\u00f6nnen JAVA in Container packen, wir k\u00f6nnen mit JAVA Python ausf\u00fchren. Aber wirklich nativ in der jeweiligen Programmiersprache und mit den ihr zugeh\u00f6rigen Bordmitteln optimalen Code produzieren. Das k\u00f6nnen wir so nicht. Wir sind unflexibel. Wir sind nicht frei in der Wahl unserer Werkzeuge.</p>"},{"location":"documents/report/report/#ziele","title":"Ziele","text":"<p>Bevor wir an die weitere Analyse gehen, m\u00f6chte ich \u00fcber die Ziele sprechen die verfolgt werden. Im Wesentlichen sind diese in diesem Blogbeitrag (bitte lesen!) hinreichend erl\u00e4utert. Zusammenfassend:</p> <ul> <li>Zielsprache Python</li> <li>Unterst\u00fctzung von INTERLIS nativ und generisch (keine Programmierung pro ILI)</li> <li>Aufbau von Workflows zum Aufzeigen des Nutzens</li> </ul>"},{"location":"documents/report/report/#ansatze","title":"Ans\u00e4tze","text":"<p>Nach diesem kurzen Rundumschlag sind wir mit den wichtigsten Inhalten vertraut, um uns in die Diskussion der m\u00f6glichen Ans\u00e4tze zu begeben.</p>"},{"location":"documents/report/report/#interlis-modell-sourcecode-parsen","title":"INTERLIS-Modell SourceCode parsen","text":"<p>Wir haben gesehen, dass die ilitools am Beispiel des INTERLIS Compilers zuerst das INTERLIS-Modell lesen (den SourceCode) und dann aus ihm das Metamodell kompilieren.</p> <p>Der Schritt des Lesens und des \"Verstehens\" ist universell in jeder Programmiersprache und findet beinahe \u00fcberall Anwendung. Textdateien werden in Maschinencode \u00fcbersetzt. Mit der Erkenntnis, dass uns das Metamodell erlaubt modular beliebige Fachapplikationen darauf aufzubauen werden wir mit einiger Voraussicht feststellen, dass auch wir bei einem \u00e4hnlichen Ansatz landen w\u00fcrden. Diesen Prozess also in Python nachzubauen, w\u00fcrde uns vorerst nicht dem eigentlichen Ziel n\u00e4her bringen. Zu gewinnen w\u00e4ren lediglich programmiersprachenspezifische Optimierungen. Diese k\u00f6nnen wir aber auch auf anderen Ebenen unseres Zielsystems implementieren. Insofern liegt es nahe, diesen Schritt vorerst einfach zu \u00fcbernehmen. Und ab fertigem Metamodell zu starten. Doch wie schaffen wir den Sprung vom in JAVA kompilierten Metamodell nach Python? Auch hier nehmen wir vorerst die Abk\u00fcrzung. Statt direkt \u00fcber JAVA zu gehen, nutzen wir die .imd Datei, die wir mit ili2c aus jedem Modell erzeugen k\u00f6nnen als Ausgangspunkt.</p>"},{"location":"documents/report/report/#rucke-vor-bis-auf-los","title":"R\u00fccke vor bis auf Los","text":"<p>Oben beschriebene Abk\u00fcrzung l\u00e4sst uns nun lediglich folgende Aufgabe zu tun: Wir m\u00fcssen einen XML-Parser bauen der das .imd lesen kann und daraus per Programmierung-on-the-fly Python-Strukturen erzeugt, welche wir dann weiternutzen k\u00f6nnen.</p>"},{"location":"documents/report/report/#python-strukturen","title":"Python-Strukturen","text":"<p>Wenn es darum geht Daten in Python zu repr\u00e4sentieren, hat man die Qual der Wahl. Daten? Ja, denn aus unserer Perspektive sind sowohl die Metamodelle, die wir mit <code>ili2c</code> erzeugen wie auch die XTF einfach nur Daten.  Mit dem kleinen Unterschied, dass und das jeweilige Metamodell den Bauplan liefert die Struktur des korrespondierenden XTF zu \"verstehen\". Letzten Endes haben wir mit dem Metamodell eigentlich alle Stricke in der Hand um vollkommen in purem Python Code zu implementieren. Das f\u00fchrt aber hier schnell zu Fragestellungen die bereits in beliebiger Tiefe durch die Python Community behandelt wurde. Der folgende Abschnitt soll aufzeigen welche Ans\u00e4tze wir haben, um Daten in Python abzubilden.</p>"},{"location":"documents/report/report/#anforderungen","title":"Anforderungen","text":"<p>Datenstrukturen in Python meint Daten in Objektform. Das heisst wir verzichten an dieser Stelle auf die Betrachtung von ORMs wie SQLAlchemy oder Django Models. Das k\u00f6nnten allenfalls Zielestrukturen sein welche man in nachgeordneten Ebenen des Prozesses anstrebt. Ziel muss ein m\u00f6glichst generische doch optimierte Repr\u00e4sentation des INTERLIS-Modells sein, um die Anwendung in einem breiten Umfeld m\u00f6glich zu machen. Doch m\u00f6chte man nicht auf spezifische Funktionalit\u00e4ten verzichten. Besonders sind dies allenfalls bereits vorhandene M\u00f6glichkeiten zum:</p> <ul> <li>De-/Serialisierung von Objekten</li> <li>Dokumentation</li> <li>Validierung nach vorgegebenen Regeln</li> <li>Pr\u00e4zisions bzw. Rundungsregeln (<code>0.00 .. 10.00</code> vs. <code>0.000 .. 10.000</code>)</li> <li>Vergleichbarkeit von Objekten</li> </ul>"},{"location":"documents/report/report/#basis","title":"Basis","text":"<p>Python unterst\u00fctzt das Paradigma der objektorientierten Programmierung und liefert uns damit alle Werkzeuge, die wir ben\u00f6tigen, um das Metamodell in Python abzubilden. Auf Details wird in der POC Implementierung eingegangen.</p> <p>Zum besseren Verst\u00e4ndnis nutzen wir ein einfaches Beispielmodell. Es beinhaltet einige INTERLIS-Definitionen anhand derer wir alles Weitere nachvollziehen k\u00f6nnen. Das diesem Beispiel zugeh\u00f6rige Metamodell soll uns noch kurz zur Betrachtung wichtiger Details dienen.</p>"},{"location":"documents/report/report/#die-natur-des-metamodells","title":"Die Natur des Metamodells","text":"<p>Der offensichtlichste aber deshalb nicht weniger wichtige Fakt ist, dass das Metamodell ein XML-Dokument ist. Weniger offensichtlich ist, dass das Metamodell ein XTF ist, und zwar nach INTERLIS 2.4 und nat\u00fcrlich nach dem INTERLIS-Modell Metamodell. Es handelt sich also um Transferdaten.</p> <p>Die Dateigr\u00f6\u00dfe von rund 350 KB mag \u00fcberraschen. Doch wenn man den Inhalt genauer anschaut, wird der Grund klar. Das imd enth\u00e4lt die komplette Beschreibung aller Modell die in der Kette durch Imports irgendwie betroffen sind. Der XML-Baum beginnt also mit dem internen INTERLIS-Modell welches alle Basisbeschreibungen von INTERLIS beinhaltet. Also der Ursuppe und dem Teil, den man eigentlich nie zu Gesicht bekommt, wenn man mit ili und xtf Dateien umgeht. Der Inhalt des Metamodells spannt sich weiter \u00fcber das Modell CoordSys und Units um dann am Ende den kleinen Teil unseres Beispielmodells abzubilden.</p> <p></p> <p>Unser Beispielmodell kann also in ca. 70 Zeilen XML beschrieben werden. Die restlichen ca. 800 Zeilen XML beschreiben den Unterbau, der f\u00fcr unser Modell n\u00f6tig ist. Das sind Koordinatensysteme (WGS84), Einheiten (Units.bar) und nat\u00fcrlich die ganzen Typen (Text, Integer, Foat) mit ihren Beschr\u00e4nkungen.</p> <p>Wir haben also mit einem Metamodell die komplette Hierarchie des Bauplanes zur Verf\u00fcgung und m\u00fcssen uns nicht mehr darum k\u00fcmmern die Inhalte der anderen Modelle irgendwie aus dem Netz zu laden. Dies wurde bei der Kompilierung durch <code>\u00ecli2c</code> vom ili ins imd bereits erledigt.</p>"},{"location":"documents/report/report/#pseudoimplementierung","title":"Pseudoimplementierung","text":"<p>In welche Richtung es gehen k\u00f6nnte, l\u00e4sst sich in der Pseudoimplementierung gut sehen. Wir repr\u00e4sentieren Elemente aus INTERLIS in korrespondierende Gegenst\u00fccke in Python. Am gezeigten Beispiel wird ersichtlich, welchen Umfang eine saubere Ableitung annehmen w\u00fcrde. Zumal l\u00e4ngst nicht alle Inhalte im Beispiel ber\u00fccksichtigt sind.</p>"},{"location":"documents/report/report/#ein-neues-rad","title":"Ein neues Rad","text":"<p>W\u00fcrde man dem oben beschriebenen Weg folgen, entst\u00fcnde ein sehr umfangreicher Satz an Python Code. Schnell kommt man an den Punkt, an dem man sich fragt, ob nicht jemand schonmal an demselben Problem sa\u00df und ob es nicht bereits gel\u00f6st sein k\u00f6nnte. Nochmal kurz benannt.</p> <p>Was ist das Problem?</p> <p>Abbildung von Datenstrukturen in Python.</p> <p>Nat\u00fcrlich wurde dieses Thema im Pyhton-Umfeld behandelt. Aus meiner Sicht stehen 3 Wege offen diesem Problem zu begegnen:</p> <ul> <li>dataclasses</li> <li>attrs</li> <li>pydantic</li> </ul> <p>Es g\u00e4be bestimmt noch weitere M\u00f6glichkeiten aber wir belassen es bei diesen, da wir keine Python-Package Rundschau betreiben, sondern an einer L\u00f6sungsskizze arbeiten wollen.</p>"},{"location":"documents/report/report/#dataclasses","title":"dataclasses","text":"<p>PRO:</p> <ul> <li>nativ in Python seit 3.7[*]</li> <li>Verhalten wie einfach Klassen</li> <li>Vergleich von Objekten (<code>field(compare=True)</code>)</li> <li>einfacher @Decorator um eine Pythonklasse zu einer dataclasses Klasse zu machen</li> <li>Validierung mit eigenen Routinen m\u00f6glich (Zeitpunkt klar)</li> <li>gutes stdout print</li> </ul> <p>CONTRA:</p> <ul> <li>Datenvalidierung umst\u00e4ndlich (z.B. via <code>__post_init__</code> Funktion) und erst nach Objektinitialisierung</li> <li>Konvertierung zwischen verschiedenen Datatypes</li> <li>Funktionsumfang h\u00e4ngt an der Pythonversion</li> </ul> <p>*(f\u00fcr den POC werden Funktionen ab Python 3.11 verwendet (<code>ENUM</code>))</p>"},{"location":"documents/report/report/#attrs","title":"attrs","text":"<p>PRO:</p> <ul> <li>Vergleich von Objekten besser steuerbar (<code>field(eq=str.lower)</code>)</li> <li>Validierung mit eigenen Routinen m\u00f6glich und einfach \u00fcber <code>field</code> oder <code>@&lt;Attributname&gt;.validator</code> zuordenbar</li> <li>Validierungszeitpunkt klar</li> <li>einfacher @Decorator um eine Pythonklasse zu einer attrs Klasse zu machen</li> <li>gutes stdout print</li> </ul> <p>CONTRA:</p> <ul> <li>Biliothek muss installiert werden (zus\u00e4tzliche Abh\u00e4ngigkeit)</li> <li>nicht verpflichtend hinsichtlich Typing</li> </ul>"},{"location":"documents/report/report/#pydantic","title":"pydantic","text":"<p>PRO:</p> <ul> <li>Datenvalidierung bereits eingebaut (<code>email</code>, <code>numbers</code>, <code>uris</code>, etc.)</li> <li>ist die Basis f\u00fcr viele Bibliotheken (DJango Ninja API, FastAPI, etc.)</li> </ul> <p>CONTRA:</p> <ul> <li>Biliothek muss installiert werden (zus\u00e4tzliche Abh\u00e4ngigkeit)</li> <li>Vererbung von <code>BaseModel</code> f\u00fchrt spezielles Verhalten der Klasse ein weg von einer Standardklasse</li> <li>kein Vergleich von Objekten</li> <li>Validierungszeitpunkt nicht klar (Objektinstanzierung, Wert\u00e4nderung, etc.)</li> <li>m\u00e4ssiges stdout print</li> </ul>"},{"location":"documents/report/report/#entscheide","title":"Entscheide","text":"<p>Die vorherigen kurzen Betrachtungen legen vorerst die Wahl von dataclasses nahe. So werden die Showcases auf dieser Basis umgesetzt. Hauptgrund ist die native Unterst\u00fctzung seit Python 3.7 (bzw. mit Enumerations 3.11).</p> <p>Die rundum komplexe Thematik des INTERLIS Metamodells l\u00e4sst eine abschliessende Umsetzung in der K\u00fcrze des POCs nicht zu. Aus diesem Grunde wird aus dem Metamodell nur umgesetzt, was wirklich f\u00fcr Demonstrationszwecke n\u00fctzlich ist. Das ist trotzdem sehr umfangreich. Insbesondere bei den Attributtypen beschr\u00e4nkt sich der POC auf die Typen TextType, NumType und das Basisverst\u00e4ndnis von Klassen, Topics sowie Attributen. Auch wenn die umgesetzte L\u00f6sung bereits die Vererbung kennt, ist diese im aktuellen POC nur rudiment\u00e4r umgesetzt. Es geh\u00f6rt also nicht zum aktuellen Funktionsumfang innerhalb von INTERLIS-Modellen die Vererbung zwischen Klassen zu verfolgen.</p>"},{"location":"documents/report/report/#anregung-fur-kunftige-diskussionen","title":"Anregung f\u00fcr k\u00fcnftige Diskussionen","text":"<p>F\u00fcr den POC wurde die Wahl getroffen. F\u00fcr eine Umsetzung hin zu einer wirklichen Bibliothek vom Charakter \u00e4hnlich den ILI-Tools muss dennoch \u00fcber die Implementierung auf den einfachen Konstrukten aus Python OOP nachgedacht werden. Nur so macht man sich m\u00f6glichst unabh\u00e4ngig von Versionen und externen Bibliotheken. Die Bausteine unserer angestrebten L\u00f6sung sind im Wesentlichen Funktionen, Klassen, Assoziationen und XML lesen/schreiben. Auf diese Basisfunktionen k\u00f6nnen dann beliebige L\u00f6sungen aufgesetzt werden. Doch das ist nicht Entscheidung des vorliegenen POC's, sondern muss in einer gr\u00f6\u00dferen Runde von k\u00fcnftigen Anwendern diskutiert werden.</p>"},{"location":"documents/report/report/#xml-und-python","title":"XML und Python","text":"<p>Beim Umgang mit INTERLIS muss unweigerlich das Problem des Datenparsens gel\u00f6st werden. \u00dcblicherweise wird in Python dazu lxml verwendet. Diese Biblothek liegt fast allen anderen Anwendungen zugrunde. Es handelt sich jedoch um eine Basisbibliothek und der Umgang mit ihr ist umst\u00e4ndlich.</p> <p>Da wir uns bereits f\u00fcr dataclasses entschieden haben und das Metamodell bekannt ist, k\u00f6nnen wir aus Zeitgr\u00fcnden eine etwas h\u00f6here Abstraktionsebene zum Parsen w\u00e4hlen. Hier setzen wir auf xsdata. Dieses Werkzeug bietet uns nicht nur die M\u00f6glichkeit XML nach einer vorher in dataclasses definierten Struktur und damit metamodellkonform zu parsen, sondern erzeugt uns auch gleich die korrespondierenden Objekte aus den dataclasses. Damit k\u00f6nnen wir dann im Python nativ arbeiten. Insgesamt spart das zwar Zeit, aber es ist auch keine unzul\u00e4ssige Abk\u00fcrzung. Der vorgestellte Ansatz funktioniert auch ohne xsdata. Explizit wurde nicht der Teil von xsdata genutzt um ein Modell aus XML oder aus XSD zu erzeugen. Die vorliegende Umsetzung bildet, soweit fortgeschritten, das Metamodell nach dem ILI und der zugeh\u00f6rigen semantischen Beschreibung im PDF ab. xsdata wird nur zum Parsen der imd XML Dateien und der XTF Dateien genutzt.</p>"},{"location":"documents/report/report/#demonstration","title":"Demonstration","text":"<p>Die Auswahl der hier erw\u00e4hnten Modelle und Daten erfolgte zuf\u00e4llig aus einem Fundus der lokal zur Verf\u00fcgung stand. Der vorgestellte Ansatz ist universeller Natur. Dennoch muss unbedingt mit Problemen gerechnet werden, wenn andere Modell-/Datenkombinationen ausprobiert werden. Zus\u00e4tzlich sei nochmal erw\u00e4hnt, dass aktuell nur Attributtypen TextType und keine Assoziationen umgesetzt sind. Das heisst, dass je nach Modell das Resultat ziemlich d\u00fcnn erscheint.</p>"},{"location":"documents/report/report/#verwendete-datenmodelle","title":"Verwendete Daten/Modelle","text":"<p>Wie bereits beschrieben wurden 3 Tests\u00e4tze zuf\u00e4llig aus einem lokalen Fundus gew\u00e4hlt. Diese S\u00e4tze bestehen immer aus einem INTERLIS-Modell (ili), dem davon abgeleiteten Metamodell (imd) und einem Beispieldatensatz (xtf).</p> <p>Die 3 Datens\u00e4tze sind:</p> INTERLIS-Modell Metamodell Datensatz Planungszonen_V1_1.ili Planungszonen_V1_1.imd ch.Planungszonen.sh.mgdm.v1_1.xtf SO_AFU_ABBAUSTELLEN_Publikation_20221103.ili SO_AFU_ABBAUSTELLEN_Publikation_20221103.imd ch.so.afu.abbaustellen.xtf OeREBKRMtrsfr_V2_0.ili OeREBKRMtrsfr_V2_0.imd ch.bazl.kataster-belasteter-standorte-zivilflugplaetze_v2_0.oereb.xtf <p>Die Erstellung eines Metamodells aus einem INTERLIS-Modell heraus kann mit <code>\u00ecli2c</code> wie folgt erreicht werden:</p> <pre><code>java -jar &lt;path-to-ili2c&gt;/ili2c.jar -oIMD16 data/OeREBKRMtrsfr_V2_0.ili --out data/OeREBKRMtrsfr_V2_0.imd\n</code></pre>"},{"location":"documents/report/report/#beispiel-1","title":"Beispiel 1","text":"<p>Es soll gezeigt werden, dass wir mit vorliegender Technik in der Lage sind, beliebige imd's zu lesen und dem Modell nach zu verstehen. Es werden Pythonstrukturen gem\u00e4ss Metamodell erzeugt. Dies ist ein zentraler Bestandteil des Konzepts. Wohlgemerkt wird hier nicht einfach xml =&gt; json umgewandelt.</p> <p>Liest das OeREBKRMtrsfr_V2_0 Modell und gibt den Inhalt als JSON aus:</p> <pre><code>ili2py-imd_json --imd data/OeREBKRMtrsfr_V2_0.imd\n</code></pre> <p>Liest das SO_AFU_ABBAUSTELLEN_Publikation_20221103 Modell und gibt den Inhalt als JSON aus:</p> <pre><code>ili2py-imd_json --imd data/SO_AFU_ABBAUSTELLEN_Publikation_20221103.imd\n</code></pre> <p>Liest das Planungszonen_V1_1 Modell und gibt den Inhalt als JSON aus:</p> <pre><code>ili2py-imd_json --imd data/Planungszonen_V1_1.imd\n</code></pre>"},{"location":"documents/report/report/#beispiel-2","title":"Beispiel 2","text":"<p>Es soll gezeigt werden, was mit dem verstandenen Datenmodell aus Beispiel 1 alles gemacht werden kann. Es wird anhand des Modells dynamisch ein Reader erzeugt, der in der Lage ist, ein XTF zu lesen welches zum Modell passt. Das bedeutet, wann immer man das Modell und die Daten hat, muss man keinen modellspezifischen Code mehr schreiben. Dieser wird zur Laufzeit erzeugt und zum Lesen der Daten verwendet.</p> <p>Liest Daten aus einem XTF nach OeREBKRMtrsfr_V2_0 Modell und gibt den Inhalt als JSON aus:</p> <pre><code>ili2py-xtf_json --imd data/OeREBKRMtrsfr_V2_0.imd --xtf data/ch.bazl.kataster-belasteter-standorte-zivilflugplaetze_v2_0.oereb.xtf --model OeREBKRMtrsfr_V2_0\n</code></pre> <p>Liest Daten aus einem XTF nach SO_AFU_ABBAUSTELLEN_Publikation_20221103 Modell und gibt den Inhalt als JSON aus:</p> <pre><code>ili2py-xtf_json --imd data/SO_AFU_ABBAUSTELLEN_Publikation_20221103.imd --xtf data/ch.so.afu.abbaustellen.xtf --model SO_AFU_ABBAUSTELLEN_Publikation_20221103\n</code></pre> <p>Liest Daten aus einem XTF nach Planungszonen_V1_1 Modell und gibt den Inhalt als JSON aus:</p> <pre><code>ili2py-xtf_json --imd data/Planungszonen_V1_1.imd --xtf data/ch.Planungszonen.sh.mgdm.v1_1.xtf --model Planungszonen_V1_1\n</code></pre>"},{"location":"documents/report/report/#beispiel-3","title":"Beispiel 3","text":"<p>Neben der dynamischen Erstellung eines modellkonformen Readers und dessen Nutzung ist die Persistierung des Codes ein anderer wichtiger Anwendungsfall. In diesem Beispiel soll gezeigt werden, dass wir mit unserem Ansatz in der Lage sind Pythonstrukturen erzeugen zu kommen welche wir sp\u00e4ter in Fachapplikationen einsetzen k\u00f6nnen. Ein denkbarer Anwendungsfall w\u00e4re hier die Erstellung eine API (CRUD/REST/OPENAPI) auf Basis des jeweiligen Modells. Oder aber direkt eine Formularl\u00f6sung (Django Forms o. \u00e4.). Alle Beispiele schreiben in eine Pythondatei.</p> <p>Liest das OeREBKRMtrsfr_V2_0 Modell und gibt den Inhalt als Python Code aus:</p> <pre><code>ili2py-xtf_reader_classes --imd data/OeREBKRMtrsfr_V2_0.imd --model OeREBKRMtrsfr_V2_0 &gt; data/OeREBKRMtrsfr_V2_0.py\n</code></pre> <p>Liest das SO_AFU_ABBAUSTELLEN_Publikation_20221103 Modell und gibt den Inhalt als Python Code aus:</p> <pre><code>ili2py-xtf_reader_classes --imd data/SO_AFU_ABBAUSTELLEN_Publikation_20221103.imd --model SO_AFU_ABBAUSTELLEN_Publikation_20221103 &gt; data/SO_AFU_ABBAUSTELLEN_Publikation_20221103.py\n</code></pre> <p>Liest das Planungszonen_V1_1 Modell und gibt den Inhalt als Python Code aus:</p> <pre><code>ili2py-xtf_reader_classes --imd data/Planungszonen_V1_1.imd --model Planungszonen_V1_1 &gt; data/Planungszonen_V1_1.py\n</code></pre>"},{"location":"documents/report/report/#ergebnisse","title":"Ergebnisse","text":"<p>Die Resultate sind ausgesprochen positiv. Mit \u00fcberschaubarem Aufwand konnte bereits das generische Grundverst\u00e4ndnis von INTERLIS in Python implementiert werden. Wir sind in der Lage beliebige Modell in Python abzuleiten. Damit ist der Grundstein f\u00fcr beliebig komplexe Fachapplikationen und Services gelegt.</p>"},{"location":"documents/report/report/#ausblick","title":"Ausblick","text":"<p>Bei der Umsetzung sind insbesondere beim auseinandersetzen des Modells zur Implementierung des XTF-Readers Unzul\u00e4nglichkeiten aufgefallen. Vorrangig betrifft das die Navigation im XML-Baum. xsdata ist unschlagbar um schnell zu L\u00f6sungen zu kommen. F\u00fcr den XTF-Reader muss aber der Baum nach Elementen durchsucht werden um Assoziationen aufl\u00f6sen zu k\u00f6nnen. Das geht mit xsdata nicht ohne Weiteres. Eine einfache Xpath Expression via lxml (z.B.: <code>//[@ili:tid=\"GeometryCHLV95_V1.SurfaceStructure\"]</code>) ist da sehr viel eleganter und vermutlich besser optimiert als alle ineinander verschachtelte Pythonschleifen, die man programmieren kann.</p> <p>Die Betrachtungen zu den Datenstrukturen in Python lassen noch Potenzial zu weiteren Untersuchungen erahnen. Hier sollten weitere Tests nicht gescheut werden, um die richtige Wahl zu treffen.</p> <p>Weiterhin bietet xsdata einen Pluginansatz mit dem man via Jinja Templates Code erzeugen kann. Das erscheint als eine vielversprechende M\u00f6glichkeit um Pythonbibliotheken zu erzeugen, die dann als Pythonpaket via pypi ver\u00f6ffentlicht werden k\u00f6nnen.</p> <p>Am wichtigsten scheint aber die Umsetzung der MultiValue Typen zu sein. Diese sind essentiell (aber komplex) f\u00fcr INTERLIS. Besonders, weil diese Typen die Geometrien definieren und damit der Weg f\u00fcr praxisn\u00e4here Beispiele geebnet w\u00e4re (QGIS drag'n'drop eines XTF).</p>"},{"location":"documents/report/report/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<p>Nach der Pr\u00e4sentation der Ergebnisse muss entschieden werden, inwiefern diese ausreichen, um ein breiteres Publikum zu animieren. Insbesondere ist die baldige Unterst\u00fctzung durch \u00fcbergeordnete Stufen zu suchen. Dies kann vorerst durch eine weitere Finanzierung im Rahmen einer gr\u00f6sseren Usergroup (BL, NE, SH, GR, TI) erfolgen. Parallel dazu sollten aber auch wieder Instanzen wie KGK oder Geostandards angefragt werden.</p> <p>Neben den architektonischen Entscheiden steht aber dann haupts\u00e4chlich die Umsetzung der Volumenarbeit an. Dabei geht es um die korrekte Abbildung aller Belange des Metamodells. Wenn diese Basisarbeit getan ist, steht ein Framework zur Verf\u00fcgung um beliebige Applikationen darauf aufzubauen.</p>"},{"location":"feature_status/","title":"Overview","text":"<p>Handling of IMD16 is split into 3 levels of processing:</p> <pre><code>flowchart TD\nreading[\"Reading/Parsing IMD16 XML\"]\nmapping[\"Mapping/Indexing into internal knowledge\"]\nrendering[\"Rendering into desired format\"]\nrendering--&gt;mapping--&gt;reading\n</code></pre> <p>The following table gives an overview about current status of the implementation:</p> Name Features implemented Coverage Comment Reading IMD16 \u23f3(123/126) ~97% All constucts out of<code>ilisMeta16.ili</code> (version 2022-04-28)can be read into Pythonsee Reading IlisMeta16 Index Mapper \u23f3(10/21) ~48% Ongoing DEV process see Index Mapper Python Classes(renderer) \u23f3 Demonstrator tool, see Python Classes UML Diagrams(renderer) \u2705(7/7) 100% Demonstrator tool, see UML Diagrams"},{"location":"feature_status/diagrams/","title":"Diagrams","text":"<p>Info</p> <p>This part is a demonstrator to show a possible usage of the python bindings.</p> <p>Its aim is to put the knowledge about the IMD16 into an automatically generated UML diagram which is never touched afterward. Usecase is the developer or data model designer who always writes Interlis models directly as text and wants an easy documentation through GitOps based workflows.</p> <p>Since the approach is purely automatic, it has its limitations. Namely, it always will lose against a manually designed and placed UML diagram in terms of readability. However, for rapid development and changes in the early project phases this is a valuable help. In addition, we can utilize different placement, connector style and filter policies to reduce the downsides to a tolerable minimum.</p> <p>As a part of the initial project we defined requirements which were refined with this comment.</p> Description Mandatory Implemented Classes \u2705 \u2705 Attributes \u2705 \u2705 Associations \u2705 \u2705 Cardinality \u2705 \u2705 Inheritance \u2705 \u2705 Data types \u2705 \u2705 Association role names on connectors \ud83d\udca1 \u274c Association names on connectors \ud83d\udca1 \u2705 Filter of drawn models by CLI parameter \ud83d\udca1 \u2705 Optimization of connector placement (Association/Inheritance) - less overlapping as possible \u26a0\ufe0f (\u2705)through <code>linetype</code> parameter for plantuml <p>Info</p> <p>\ud83d\udca1 = <code>Nice To Have</code></p> <p>\u26a0\ufe0f = <code>Should-have</code></p> <p>When ever relevant, this implementation follows Interlis umleditor style as reference.</p>"},{"location":"feature_status/ilismeta16/","title":"Reading IlisMeta16","text":"<p>This is about the necessary constructions to read an arbitrary INTERLIS Metamodel File (<code>*.imd</code>) in the IMD16 format. So about parsing the XML/XTF.</p> <p>The following overview tries to reflect the order and structure how it is defined in the above linked ILI file.</p>"},{"location":"feature_status/ilismeta16/#metaelements-in-general","title":"MetaElements in general","text":"Construct ili Kind Mandatory v1 Implemented ModelData.DocText STRUCTURE \u2705 \u2705 ModelData.MetaElement CLASS ABSTRACT \u2705 \u2705 ModelData.MetaAttribute CLASS \u2705 \u2705 ModelData.MetaAttributes ASSOCIATION \u2705 \u2705 ModelData.ExtendableME CLASS \u2705 \u2705 ModelData.Inheritance ASSOCIATION \u2705 \u2705"},{"location":"feature_status/ilismeta16/#models","title":"Models","text":"Construct ili Kind Mandatory v1 Implemented ModelData.Package CLASS ABSTRACT \u2705 \u2705 ModelData.Ili1Format STRUCTURE \u2705 \u2705 ModelData.Model CLASS \u2705 \u2705 ModelData.SubModel CLASS \u2705 \u2705 ModelData.PackageElements ASSOCIATION \u2705 \u2705 ModelData.Import ASSOCIATION \u274c \u2705 ModelData.Type CLASS \u2705 \u2705 ModelData.Expression STRUCTURE \u2705 \u2705 ModelData.Multiplicity STRUCTURE \u2705 \u2705 ModelData.Constraint CLASS ABSTRACT \u2705 \u2705 ModelData.DomainType CLASS ABSTRACT \u2705 \u2705 ModelData.DomainConstraint ASSOCIATION \u274c \u2705"},{"location":"feature_status/ilismeta16/#classes","title":"Classes","text":"Construct ili Kind Mandatory v1 Implemented ModelData.Class CLASS \u2705 \u2705 ModelData.AttrOrParam CLASS \u2705 \u2705 ModelData.ClassConstraint ASSOCIATION \u2705 \u2705 ModelData.LocalType ASSOCIATION \u274c \u2705 ModelData.AttrOrParamType ASSOCIATION \u2705 \u2705 ModelData.ClassAttr ASSOCIATION \u2705 \u2705 ModelData.ClassParam ASSOCIATION \u2705 \u2705"},{"location":"feature_status/ilismeta16/#types-related-to-other-types","title":"Types related to other types","text":"Construct ili Kind Mandatory v1 Implemented ModelData.TypeRelatedType CLASS ABSTRACT \u2705 \u2705 ModelData.BaseType ASSOCIATION \u2705 \u2705 ModelData.TypeRestriction ASSOCIATION \u274c \u2705"},{"location":"feature_status/ilismeta16/#bag-type","title":"Bag type","text":"Construct ili Kind Mandatory v1 Implemented ModelData.MultiValue CLASS \u2705 \u2705"},{"location":"feature_status/ilismeta16/#references-and-associations","title":"References and associations","text":"Construct ili Kind Mandatory v1 Implemented ModelData.ClassRelatedType CLASS ABSTRACT \u2705 \u2705 ModelData.BaseClass ASSOCIATION \u2705 \u2705 ModelData.ClassRestriction ASSOCIATION \u274c \u2705 ModelData.ReferenceType CLASS \u2705 \u2705 ModelData.Role CLASS \u2705 \u2705 ModelData.AssocRole ASSOCIATION \u2705 \u2705 ModelData.ExplicitAssocAccess CLASS \u274c \u2705 ModelData.ExplicitAssocAcc ASSOCIATION \u274c \u2705 ModelData.AssocAccOrigin ASSOCIATION \u274c \u2705 ModelData.AssocAccTarget ASSOCIATION \u274c \u2705 ModelData.AssocAcc ASSOCIATION \u2705 \u274c(not exported by ili2c 5.6.6)"},{"location":"feature_status/ilismeta16/#information-for-easy-transfer","title":"Information for easy transfer","text":"Construct ili Kind Mandatory v1 Implemented ModelData.TransferElement ASSOCIATION \u274c \u2705 ModelData.Ili1TransferElement ASSOCIATION \u274c \u2705"},{"location":"feature_status/ilismeta16/#dataunits","title":"DataUnits","text":"Construct ili Kind Mandatory v1 Implemented ModelData.DataUnit CLASS \u2705 \u2705 ModelData.Dependency ASSOCIATION \u274c \u2705 ModelData.AllowedInBasket ASSOCIATION \u274c \u2705"},{"location":"feature_status/ilismeta16/#generics-and-contexts-interlis-24-only","title":"Generics and Contexts (INTERLIS 2.4 only)","text":"Construct ili Kind Mandatory v1 Implemented ModelData.Context CLASS \u274c \u2705 ModelData.GenericDef ASSOCIATION \u274c \u2705 ModelData.ConcreteForGeneric ASSOCIATION \u274c \u2705"},{"location":"feature_status/ilismeta16/#units","title":"Units","text":"Construct ili Kind Mandatory v1 Implemented ModelData.Unit CLASS (\u2705) \u2705"},{"location":"feature_status/ilismeta16/#metaobjects","title":"MetaObjects","text":"Construct ili Kind Mandatory v1 Implemented ModelData.MetaBasketDef CLASS \u274c \u2705 ModelData.MetaDataUnit ASSOCIATION \u274c \u2705 ModelData.MetaObjectDef CLASS \u274c \u2705 ModelData.MetaBasketMembers ASSOCIATION \u274c \u2705 ModelData.MetaObjectClass ASSOCIATION \u274c \u2705"},{"location":"feature_status/ilismeta16/#base-types","title":"Base types","text":"Construct ili Kind Mandatory v1 Implemented ModelData.BooleanType CLASS \u2705 \u2705 ModelData.TextType CLASS \u2705 \u2705 ModelData.BlackboxType CLASS \u2705 \u2705 ModelData.NumType CLASS \u2705 \u2705 ModelData.NumUnit ASSOCIATION \u2705 \u2705 ModelData.CoordType CLASS \u2705 \u2705 ModelData.AxisSpec ASSOCIATION \u2705 \u2705 ModelData.NumsRefSys ASSOCIATION \u2705 \u2705 ModelData.FormattedType CLASS \u2705 \u2705 ModelData.StructOfFormat ASSOCIATION \u2705 \u2705"},{"location":"feature_status/ilismeta16/#oid-definition","title":"OID Definition","text":"Construct ili Kind Mandatory v1 Implemented ModelData.AnyOIDType CLASS \u2705 \u2705 ModelData.ObjectOID ASSOCIATION \u2705 \u2705 ModelData.BasketOID ASSOCIATION \u2705 \u2705"},{"location":"feature_status/ilismeta16/#functions","title":"Functions","text":"Construct ili Kind Mandatory v1 Implemented ModelData.FunctionDef CLASS \u274c \u2705 ModelData.LocalFType ASSOCIATION \u274c \u2705 ModelData.ResultType ASSOCIATION \u274c \u2705 ModelData.Argument CLASS \u274c \u2705 ModelData.FormalArgument ASSOCIATION \u274c \u2705 ModelData.ArgumentType ASSOCIATION \u274c \u2705"},{"location":"feature_status/ilismeta16/#class-and-attribute-reference-types","title":"Class and attribute reference types","text":"Construct ili Kind Mandatory v1 Implemented ModelData.ClassRefType CLASS \u2705 \u2705 ModelData.ObjectType CLASS \u2705 \u2705 ModelData.AttributeRefType CLASS \u274c \u2705 ModelData.ARefOf ASSOCIATION \u274c \u2705 ModelData.ARefRestriction ASSOCIATION \u274c \u2705"},{"location":"feature_status/ilismeta16/#enumerations","title":"Enumerations","text":"Construct ili Kind Mandatory v1 Implemented ModelData.EnumType CLASS \u2705 \u2705 ModelData.EnumNode CLASS \u2705 \u2705 ModelData.TopNode ASSOCIATION \u2705 \u2705 ModelData.SubNode ASSOCIATION \u2705 \u2705 ModelData.EnumTreeValueType CLASS \u2705 \u2705 ModelData.TreeValueTypeOf ASSOCIATION \u2705 \u2705"},{"location":"feature_status/ilismeta16/#line-types","title":"Line types","text":"Construct ili Kind Mandatory v1 Implemented ModelData.LineForm CLASS \u2705 \u2705 ModelData.LineFormStructure ASSOCIATION \u2705 \u2705 ModelData.LineType CLASS \u2705 \u2705 ModelData.LinesForm ASSOCIATION \u2705 \u2705 ModelData.LineCoord ASSOCIATION \u2705 \u2705 ModelData.LineAttr ASSOCIATION \u274c \u2705"},{"location":"feature_status/ilismeta16/#views","title":"Views","text":"Construct ili Kind Mandatory v1 Implemented ModelData.View CLASS \u2705 \u2705 ModelData.RenamedBaseView CLASS \u2705 \u2705 ModelData.BaseViewDef ASSOCIATION \u2705 \u2705 ModelData.BaseViewRef ASSOCIATION \u2705 \u2705 ModelData.DerivedAssoc ASSOCIATION \u2705 \u2705"},{"location":"feature_status/ilismeta16/#expressions-factors","title":"Expressions, factors","text":"Construct ili Kind Mandatory v1 Implemented ModelData.UnaryExpr STRUCTURE \u2705 \u2705 ModelData.CompoundExpr STRUCTURE \u2705 \u2705 ModelData.Factor STRUCTURE \u2705 \u2705 ModelData.PathEl STRUCTURE \u2705 \u2705 ModelData.PathOrInspFactor STRUCTURE \u2705 \u2705 ModelData.EnumAssignment STRUCTURE \u274c \u2705 ModelData.EnumMapping STRUCTURE \u274c \u2705 ModelData.ClassRef STRUCTURE \u274c \u2705 ModelData.ActualArgument STRUCTURE \u274c \u2705 ModelData.FunctionCall STRUCTURE \u274c \u2705 ModelData.RuntimeParamRef STRUCTURE \u274c \u2705 ModelData.Constant STRUCTURE \u2705 \u2705 ModelData.ClassConst STRUCTURE \u274c \u2705 ModelData.AttributeConst STRUCTURE \u274c \u2705 ModelData.UnitRef STRUCTURE \u2705 \u2705 ModelData.UnitFunction STRUCTURE \u2705 \u2705"},{"location":"feature_status/ilismeta16/#constraints","title":"Constraints","text":"Construct ili Kind Mandatory v1 Implemented ModelData.SimpleConstraint CLASS \u2705 \u2705 ModelData.ExistenceConstraint CLASS \u274c \u2705 ModelData.ExistenceDef ASSOCIATION \u274c \u2705 ModelData.UniqueConstraint CLASS \u2705 \u2705 ModelData.SetConstraint CLASS \u2705 \u2705"},{"location":"feature_status/ilismeta16/#graphic","title":"Graphic","text":"Construct ili Kind Mandatory v1 Implemented ModelData.Graphic CLASS \u274c \u2705 ModelData.GraphicBase ASSOCIATION \u274c \u2705 ModelData.SignParamAssignment STRUCTURE \u274c \u2705 ModelData.CondSignParamAssignment STRUCTURE \u274c \u2705 ModelData.DrawingRule CLASS \u274c \u2705 ModelData.GraphicRule ASSOCIATION \u274c \u2705 ModelData.SignClass ASSOCIATION \u274c \u2705"},{"location":"feature_status/ilismeta16/#translation","title":"Translation","text":"Construct ili Kind Mandatory v1 Implemented ModelTranslation.DocTextTranslation STRUCTURE \u2705 \u274c(not exported by ili2c 5.6.6) ModelTranslation.METranslation STRUCTURE \u2705 \u274c(not exported by ili2c 5.6.6) ModelTranslation.Translation CLASS \u2705 \u274c(not exported by ili2c 5.6.6)"},{"location":"feature_status/index_mapper/","title":"Index Mapper","text":"<p>This part is topped up on features used by subsequent tools. Main purpose of this is about resolving Associations, easing the access between linked elements for later usage. For example, it gives easy access to all the attributes of a class without any additional iteration as it is really helpful for UML and Python Class generation.</p> <p>In the current status as of 09/2025 we consider 21/51 ASSOCIATIONS in ilisMeta16 as helpful candidates for indexing.</p>"},{"location":"feature_status/index_mapper/#metaelements-in-general","title":"MetaElements in general","text":"Construct ili Kind Mandatory v1 Implemented ModelData.MetaAttributes ASSOCIATION \u2705 \u2705<code>Index().metaelement_metaattributes</code> ModelData.Inheritance ASSOCIATION \u2705 `0..1(not relevant)"},{"location":"feature_status/index_mapper/#models","title":"Models","text":"Construct ili Kind Mandatory v1 Implemented ModelData.PackageElements ASSOCIATION \u2705 <code>0..1</code>(not relevant) ModelData.Import ASSOCIATION \u274c \u2705<code>Index().imported_p</code><code>Index().importing_p</code> ModelData.DomainConstraint ASSOCIATION \u274c \u274cno usecase in tested models"},{"location":"feature_status/index_mapper/#classes","title":"Classes","text":"Construct ili Kind Mandatory v1 Implemented ModelData.ClassConstraint ASSOCIATION \u2705 \u274cno usecase in tested models ModelData.LocalType ASSOCIATION \u274c <code>0..1</code>(not relevant) ModelData.AttrOrParamType ASSOCIATION \u2705 <code>1</code>(not relevant) ModelData.ClassAttr ASSOCIATION \u2705 \u2705<code>Index().class_class_attribute</code> ModelData.ClassParam ASSOCIATION \u2705 \u2705<code>Index().class_class_parameter</code>"},{"location":"feature_status/index_mapper/#types-related-to-other-types","title":"Types related to other types","text":"Construct ili Kind Mandatory v1 Implemented ModelData.BaseType ASSOCIATION \u2705 <code>1</code>(not relevant) ModelData.TypeRestriction ASSOCIATION \u274c \u274cno usecase in tested models"},{"location":"feature_status/index_mapper/#bag-type","title":"Bag type","text":"<p>No Associations in this group.</p>"},{"location":"feature_status/index_mapper/#references-and-associations","title":"References and associations","text":"Construct ili Kind Mandatory v1 Implemented ModelData.BaseClass ASSOCIATION \u2705 \u2705<code>Index().base_class</code><code>Index().class_related_type</code> ModelData.ClassRestriction ASSOCIATION \u274c \u274c ModelData.AssocRole ASSOCIATION \u2705 <code>1</code>(not relevant) ModelData.ExplicitAssocAcc ASSOCIATION \u274c \u274c ModelData.AssocAccOrigin ASSOCIATION \u274c \u274c ModelData.AssocAccTarget ASSOCIATION \u274c \u274c ModelData.AssocAcc ASSOCIATION \u2705 \u274c(pending clarification)"},{"location":"feature_status/index_mapper/#information-for-easy-transfer","title":"Information for easy transfer","text":"Construct ili Kind Mandatory v1 Implemented ModelData.TransferElement ASSOCIATION \u274c \u2705<code>Index().transfer_element</code><code>Index().transfer_class</code> ModelData.Ili1TransferElement ASSOCIATION \u274c (not relevant)"},{"location":"feature_status/index_mapper/#dataunits","title":"DataUnits","text":"Construct ili Kind Mandatory v1 Implemented ModelData.Dependency ASSOCIATION \u274c \u2705<code>Index().dependency_depends_on</code><code>Index().dependency_used_by</code> ModelData.AllowedInBasket ASSOCIATION \u274c \u2705<code>Index().allowed_in_basket_class_in_basket</code><code>Index().allowed_in_basket_of_data_unit</code>"},{"location":"feature_status/index_mapper/#generics-and-contexts-interlis-24-only","title":"Generics and Contexts (INTERLIS 2.4 only)","text":"Construct ili Kind Mandatory v1 Implemented ModelData.GenericDef ASSOCIATION \u274c \u274c ModelData.ConcreteForGeneric ASSOCIATION \u274c \u274c"},{"location":"feature_status/index_mapper/#units","title":"Units","text":"<p>No Associations in this group.</p>"},{"location":"feature_status/index_mapper/#metaobjects","title":"MetaObjects","text":"Construct ili Kind Mandatory v1 Implemented ModelData.MetaDataUnit ASSOCIATION \u274c <code>1</code>(not relevant) ModelData.MetaBasketMembers ASSOCIATION \u274c <code>&lt;#&gt;</code>(not relevant) ModelData.MetaObjectClass ASSOCIATION \u274c <code>1</code>(not relevant)"},{"location":"feature_status/index_mapper/#base-types","title":"Base types","text":"Construct ili Kind Mandatory v1 Implemented ModelData.NumUnit ASSOCIATION \u2705 <code>1</code>(not relevant) ModelData.AxisSpec ASSOCIATION \u2705 \u2705<code>Index().coord_type</code><code>Index().axis</code> ModelData.NumsRefSys ASSOCIATION \u2705 <code>0..1</code>(not relevant) ModelData.StructOfFormat ASSOCIATION \u2705 <code>1</code>(not relevant)"},{"location":"feature_status/index_mapper/#oid-definition","title":"OID Definition","text":"Construct ili Kind Mandatory v1 Implemented ModelData.ObjectOID ASSOCIATION \u2705 <code>0..1</code>(not relevant) ModelData.BasketOID ASSOCIATION \u2705 <code>0..1</code>(not relevant)"},{"location":"feature_status/index_mapper/#functions","title":"Functions","text":"Construct ili Kind Mandatory v1 Implemented ModelData.LocalFType ASSOCIATION \u274c <code>0..1</code>(not relevant) ModelData.ResultType ASSOCIATION \u274c <code>1</code>(not relevant) ModelData.FormalArgument ASSOCIATION \u274c <code>&lt;#&gt;</code>(not relevant) ModelData.ArgumentType ASSOCIATION \u274c <code>0..1</code>(not relevant)"},{"location":"feature_status/index_mapper/#class-and-attribute-reference-types","title":"Class and attribute reference types","text":"Construct ili Kind Mandatory v1 Implemented ModelData.ARefOf ASSOCIATION \u274c <code>0..1</code>(not relevant) ModelData.ARefRestriction ASSOCIATION \u274c \u274c"},{"location":"feature_status/index_mapper/#enumerations","title":"Enumerations","text":"Construct ili Kind Mandatory v1 Implemented ModelData.TopNode ASSOCIATION \u2705 <code>1</code>(not relevant) ModelData.SubNode ASSOCIATION \u2705 <code>&lt;#&gt;</code>(not relevant) ModelData.TreeValueTypeOf ASSOCIATION \u2705 <code>1</code>(not relevant)"},{"location":"feature_status/index_mapper/#line-types","title":"Line types","text":"Construct ili Kind Mandatory v1 Implemented ModelData.LineFormStructure ASSOCIATION \u2705 <code>1</code>(not relevant) ModelData.LinesForm ASSOCIATION \u2705 \u2705<code>Index().line_form</code><code>Index().line_type</code> ModelData.LineCoord ASSOCIATION \u2705 <code>0..1</code>(not relevant) ModelData.LineAttr ASSOCIATION \u274c <code>0..1</code>(not relevant)"},{"location":"feature_status/index_mapper/#views","title":"Views","text":"Construct ili Kind Mandatory v1 Implemented ModelData.BaseViewDef ASSOCIATION \u2705 <code>&lt;#&gt;</code>(not relevant) ModelData.BaseViewRef ASSOCIATION \u2705 <code>1</code>(not relevant) ModelData.DerivedAssoc ASSOCIATION \u2705 <code>0..1</code>(not relevant)"},{"location":"feature_status/index_mapper/#expressions-factors","title":"Expressions, factors","text":"<p>No Associations in this group.</p>"},{"location":"feature_status/index_mapper/#constraints","title":"Constraints","text":"Construct ili Kind Mandatory v1 Implemented ModelData.ExistenceDef ASSOCIATION \u274c <code>&lt;#&gt;</code>(not relevant)"},{"location":"feature_status/index_mapper/#graphic","title":"Graphic","text":"Construct ili Kind Mandatory v1 Implemented ModelData.GraphicBase ASSOCIATION \u274c <code>0..1</code>(not relevant) ModelData.GraphicRule ASSOCIATION \u274c <code>&lt;#&gt;</code>(not relevant) ModelData.SignClass ASSOCIATION \u274c <code>0..1</code>(not relevant)"},{"location":"feature_status/index_mapper/#translation","title":"Translation","text":"<p>No Associations in this group.</p>"},{"location":"feature_status/python_classes/","title":"Python Classes","text":"<p>Info</p> <p>This part is a demonstrator to show a possible usage of the python bindings.</p> <p>Its aim is to generate a pure python library reflecting the understanding of the underlying Interlis model. Meaning a low level network of interdependent classes which may be used to read XTF-data of the model in question, but also access the specifics of the model like constraints, types, restrictions etc.</p> <p>It should not be understood as a standalone library serving already a purpose but as a basic compilation artifact which then can be used in domain specific python applications to handle the desired data. This way the application can be written with a mapping layer to the compiled interface. In case the underling Interlis model changes, only that layer has to be adapted to the newly compiled version of the interface.</p> <p>Why to compile the model to source coda anyway? This is a performance question and a matter of explicit formulation. This enables usage of known development toolchains like gitops, packaging. In addition, it enables developer convenience type-completion while coding, typing, in editor docs, prevention of errors.</p> <p>As a part of the initial project we defined requirements</p> Description Mandatory Implemented one python package per INTERLIS model \u2705 \u2705 everything within a model without TOPIC goes to <code>__init__.py</code> \u2705 \u2705 one python file per topic in the regarding model package \u2705 \u2705 Classes will be Python classes \u2705 \u2705 attributes will be Python class attributes \u2705 \u2705 attribute types will be defined in the pythonic way  (library has to be self containing) \u2705 \u2705 Domain-Definitions are stored in <code>__init__.py</code> \u2705 \u2705 Type constraints are read and stored so that other tools can use them later. ili2py does not validate those. \u2705 \u2705 Constraints are read and stored so that other tools can use them later. ili2py does not validate those. \u2705 \u2705 Inline documentation from model files (ili) is stored as Docstrings for each corresponding element. The style of the python doc strings is the Google notation since it is well readable in the source code and widely supported by tools. \u2705 \u2705 Associations are stored as references. This is done to be agnostic to later usage in tools. With this construction associations can always be determined cleanly. \u2705 \u2705 Information about association constraints (e.g. 1:n, etc.) are read and stored for later use by other tools. ili2py does not validate those. \u2705 \u2705 Inheritance is implemented with Python class inheritance 1:1 as defined in the INTERLIS model. \u2705 \u2705"},{"location":"feature_status/questions/","title":"Open Questions","text":"<p>Used ili2c version: 5.6.6</p> <p>During the intense work with IMD16 which were produced by ili2c, some questions came up. These are summarized here. These Questions are not exclusively related to the compiler but may also be related to the Reference Manual of INTERLIS 2.4</p>"},{"location":"feature_status/questions/#missing-topic-ilismeta16modeltranslation-in-imd16","title":"Missing Topic ilisMeta16.ModelTranslation in IMD16","text":"<p>Issue created: https://github.com/claeis/ili2c/issues/149 =&gt; it should be solved with next release</p>"},{"location":"feature_status/questions/#missing-interlisutchours-in-imd16","title":"Missing INTERLIS.UTC.Hours in IMD16","text":"<p>It seems that several pieces of the INTERLIS model are missing. On behalf of that <code>INTERLIS.UTC.Hours</code> is cited as an example.</p>"},{"location":"feature_status/questions/#difference-of-mandatory-and-multiplicity","title":"Difference of mandatory and multiplicity","text":"<p>It came to attention, that types carry both information <code>multiplicity</code> and <code>mandatory</code>. Even if these serves different purposes and they are correctly set, it seems a bit awkward having both. ili2py trades this information transparently forward. However, it might be a good idea to overcome this in the next iteration of INTERLIS.</p>"},{"location":"feature_status/questions/#oids-are-not-transported-comprehensible","title":"OIDs are not transported comprehensible","text":"<p>In cases where a topic of one model (B) extends a topic of another model (A) and in Domain of model A there is an OID defined, the OID is set only in the Topics of model A when they extend each other. But when a model B contains a Topic extending a Topic of A (which defines an OID), then no OID is present on classes of topic in model B.</p> <p>Example is: OeREBKRM_V2_0 and OeREBKRMtrsfr_V2_0 where OeREBKRMtrsfr_V2_0 defines topic Transferstruktur extending OeREBKRM_V2_0.Amt. OeREBKRM_V2_0.Amt defines <code>OID AS OEREBOID;</code> but all classes from OeREBKRMtrsfr_V2_0.Transferstruktur have <code>oid=Null</code> in the resulting IMD16.</p>"},{"location":"feature_status/questions/#version-of-modeldatamodel-not-in-imd16-24","title":"Version of ModelData.Model not in IMD16 (2.4)","text":"<p>When creating IMD16 with ili2c from 2.4 Models (e.g. Waldreservate_V2_0), the element <code>ModelData.Model</code> <code>ModelData.Model.Version</code> is missing.</p>"},{"location":"feature_status/questions/#ilismeta16operation-nested-in-ilismeta16unaryexpr","title":"IlisMeta16.Operation 'Nested' in IlisMeta16.UnaryExpr","text":"<p>Ili model IlisMeta16 defines: </p> <p>But imd16 generated with ili2c 5.6.6 delivers an operation 'Nested': </p> <p>Example models: - SZ_Lebensraum_Fisch_V2 - Hazard_Mapping_LV95_V1_3 - DMAV_HoheitsgrenzenAV_V1_0 - DMAV_Grundstuecke_V1_0 - DMAV_Dienstbarkeitsgrenzen_V1_0 - DMAV_Gebaeudeadressen_V1_0 - KbS_V1_5 - ...</p>"},{"location":"feature_status/questions/#potentially-missing-ilismeta16existencedeftype-in-imd16-exports","title":"Potentially missing IlisMeta16.ExistenceDefType in imd16 exports","text":"<p>ili2c 5.6.6 seems to miss the ExistenceDefType association in imd16 exports. It seems to be missing in the XSD too: </p> <p>Example model: - DMAVTYM_Alles_V1_0</p>"},{"location":"feature_status/questions/#potentially-missing-ilismeta16enumassignment-in-imd16-exports","title":"Potentially missing IlisMeta16.EnumAssignment in imd16 exports","text":"<p>ili2c 5.6.6 seems to miss the EnumAssignment association in imd16 exports.</p> <p>Example model: - DMAVTYM_Alles_V1_0</p>"},{"location":"feature_status/questions/#how-are-the-geometric-overlaps-constraint-unit-transported-in-ilismeta16","title":"How are the geometric overlaps constraint unit transported in IlisMeta16?","text":"<p>Currently, we can have IlisMeta16:LineType.IlisMeta16:MaxOverlap in IlisMeta16 but it's not clear where the unit is coming from.</p> <p>Not sure if this is relevant, because there is also no unit defined in e.g. GeometryCHLV95_V1</p>"},{"location":"feature_status/questions/#encoding-of-directed-polylines","title":"Encoding of directed polylines","text":"<p>It's not clear from data nor reference manuals (2.3 and 2.4) how a directed polyline is encoded in XTF.</p>"},{"location":"user_guide/cli-binary/","title":"CLI Binary usage","text":""},{"location":"user_guide/cli-binary/#cli-binary-version","title":"CLI (Binary version)","text":"<p>The binary version of ili2py cli can be downloaded from the Releases Page on GitHub</p> <p>As described above, the Command Line Interface of ili2py offerse two sub commands besides the main command:</p> <ul> <li><code>diagram</code></li> <li><code>python-classes</code></li> </ul> <p>Let's have a look how it is used.</p>"},{"location":"user_guide/cli-binary/#main-command","title":"Main command","text":"<p>Tip</p> <p>Its possible that you need to execute <code>chmod +x ili2py-linux</code>/ <code>chmod +x ili2py-macos</code> for the first time.</p> <pre><code># Linux (possibly chmod +x ili2py-linux)\n./ili2py-linux\n\n# Mac (possibly chmod +x ili2py-macos)\n./ili2py-macos\n\n# Windows\n.\\ili2py-windows.exe\n</code></pre> <p>Tip</p> <p>The same output you get with <code>--help</code></p> <pre><code># Linux\n./ili2py-linux --help\n\n# Mac\n./ili2py-macos --help\n\n# Windows\n.\\ili2py-windows.exe --help\n</code></pre> <p>With <code>-V</code>/<code>--version</code> you can output the used version.</p> <pre><code># Linux\n./ili2py-linux --V\n./ili2py-linux --version\n\n# Mac\n./ili2py-macos --V\n./ili2py-macos --version\n\n# Windows\n.\\ili2py-windows.exe --V\n.\\ili2py-windows.exe --version\n</code></pre> <p>Output: </p><pre><code>ili2py 0.0.1 from ./ili2py-linux (Python 3.13.7)\n</code></pre><p></p> <p>Note</p> <p>The parameter <code>-v</code>/<code>--verbose</code> is used only in connection with the sub commands.</p>"},{"location":"user_guide/cli-binary/#sub-command-diagram","title":"Sub command <code>diagram</code>","text":"<p>Creates a diagram of your choice from an IlisMeta16 file input.</p> <p>Info</p> <p>ili2py does not render the final image. It creates the dedicated textual representation. You need to render the resulting image by yourself with the matching toolset.</p> <pre><code># Linux\n./ili2py-linux diagram --help\n\n# Mac\n./ili2py-macos diagram --help\n\n# Windows\n.\\ili2py-windows.exe diagram --help\n</code></pre> <p>The mandatory parameters of the sub command <code>diagram</code> are:</p> <ul> <li>the path to the meta model <code>-i</code>/<code>--imd</code> (only IMD16 is allowed!)</li> <li>and the path where the result should be written to <code>-o</code>/<code>--output_folder</code></li> </ul> <p>Info</p> <p>A subfolder <code>output_folder</code> with the name of the flavor will be created.</p> <p>All other parameters are optional:</p> <ul> <li><code>-f</code>/<code>--flavour</code> =&gt; Which diagram type should be created. Currently <code>plantuml</code>, <code>plantuml_role_members</code>, <code>mermaid</code>, <code>dot</code> (experimental) are implemented. Default type is <code>mermaid</code>.</li> <li><code>-d</code>/<code>--direction</code> =&gt; In which direction should the diagram be drawn. This depends on the selected <code>flavour</code>:<ul> <li><code>mermaid</code> =&gt; <code>LR</code>, <code>RL</code>, <code>TD</code>, <code>DT</code> =&gt; default <code>LR</code></li> <li><code>plantuml</code> =&gt; <code>'top to bottom'</code>, <code>'left to right'</code>  =&gt; default <code>'top to bottom'</code></li> <li><code>plantuml_role_members</code> =&gt; <code>'top to bottom'</code>, <code>'left to right'</code>  =&gt; default <code>'top to bottom'</code></li> <li><code>dot</code> =&gt; No setting available</li> </ul> </li> <li><code>-l</code>/<code>--linetype</code> =&gt; Of which kind should be the inter-class-connectors. This depends on the selected <code>flavour</code>:<ul> <li><code>mermaid</code> =&gt; No setting available</li> <li><code>plantuml</code> =&gt; <code>polyline</code>, <code>ortho</code>, <code>spline</code></li> <li><code>dot</code> =&gt; No setting available</li> </ul> </li> <li><code>-n</code>/<code>--file_name</code> =&gt; The name of the diagram file. Without file extension, this is defined by the <code>flavour</code> and is added automatically.</li> <li><code>-m</code>/<code>--models</code> =&gt; A comma-separated list of ili model names. These are used as a filter on the content of the diagram. Only models contained in the list will be drawn on the diagram. If the list is empty (default), all models will be drawn.</li> <li><code>--depth</code> =&gt; A filter based on the analysis of the import tree.</li> </ul> <p>Info</p> <p>If command line parameters contain spaces, they must be wrapped into quotation marks <code>'a b c'</code> oder <code>\"a b c\"</code>!</p> <p>The following command creates a mermaid diagram (markdown file) containing the elements of the model <code>OeREBKRMtrsfr_V2_0</code> (filter). The file is named <code>diagram.md</code> and is located in the newly created folder <code>mermaid</code>.</p> <pre><code># Linux\n./ili2py-linux diagram -i models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o ./ -m OeREBKRMtrsfr_V2_0\n\n# Mac\n./ili2py-macos diagram -i models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o ./ -m OeREBKRMtrsfr_V2_0\n\n# Windows\n.\\ili2py-windows.exe diagram -i models\\OeREBKRMtrsfr_V2_0\\OeREBKRMtrsfr_V2_0.imd -o .\\ -m OeREBKRMtrsfr_V2_0\n</code></pre> <p>The following command creates the same diagram but outputs a lot more logs. This is useful in cases you experience errors and need to investigate.</p> <pre><code># Linux\n./ili2py-linux -v diagram -i models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o ./ -m OeREBKRMtrsfr_V2_0\n\n# Mac\n./ili2py-macos -v diagram -i models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o ./ -m OeREBKRMtrsfr_V2_0\n\n# Windows\n.\\ili2py-windows.exe -v diagram -i models\\OeREBKRMtrsfr_V2_0\\OeREBKRMtrsfr_V2_0.imd -o .\\ -m OeREBKRMtrsfr_V2_0\n</code></pre>"},{"location":"user_guide/cli-binary/#sub-command-python-classes","title":"Sub command <code>python-classes</code>","text":"<p>Creates typed python class library out of an IlisMeta16 file input.</p> <p></p><pre><code># Linux\n./ili2py-linux python-classes --help\n\n# Mac\n./ili2py-macos python-classes --help\n\n# Windows\n.\\ili2py-windows.exe python-classes --help\n</code></pre> The mandatory parameters of the sub command python-classes` are:<p></p> <ul> <li>the path to the meta model <code>-i</code>/<code>--imd</code> (only IMD16 is allowed!)</li> <li>and the path where the result should be written to <code>-o</code>/<code>--output_folder</code></li> </ul> <p>Info</p> <p>A subfolder <code>output_folder</code> with the name of the flavor will be created.</p> <p>Optional parameters are:</p> <ul> <li><code>-l</code>/<code>--library_name</code> =&gt; The name of the resulting library.</li> </ul> <p>Tip</p> <p>This can be a point separated name. The library is created to be in the scope of that path (internal imports are aligned). This way you can integrate the generated library easily in existing projects.</p> <p>Info</p> <p>If the name is <code>ili2py.interfaces.interlis.OeREBKRMtrsfr_V2_0</code>, the library will be created still in the folder <code>OeREBKRMtrsfr_V2_0</code>. It has to be copied to the correct place manually then.</p> <p>The following command creates a python library in the folder <code>OeREBKRMtrsfr_V2_0</code>:</p> <pre><code># Linux\n./ili2py-linux python-classes -i models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o ./ -l interface\n\n# Mac\n./ili2py-macos python-classes -i models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o ./ -l interface\n\n# Windows\n.\\ili2py-windows.exe python-classes -i models\\OeREBKRMtrsfr_V2_0\\OeREBKRMtrsfr_V2_0.imd -o .\\ -l interface\n</code></pre> <p>The following command creates the same library. But it puts out a lot more logs.</p> <pre><code># Linux\n./ili2py-linux python-classes -i models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o ./ -l interface\n\n# Mac\n./ili2py-macos python-classes -i models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o ./ -l interface\n\n# Windows\n.\\ili2py-windows.exe python-classes -i models\\OeREBKRMtrsfr_V2_0\\OeREBKRMtrsfr_V2_0.imd -o .\\ -l interface\n</code></pre>"},{"location":"user_guide/cli-reference/","title":"CLI Reference","text":""},{"location":"user_guide/cli-reference/#cli-reference","title":"CLI Reference","text":"<p>This page provides documentation for our command line tools.</p>"},{"location":"user_guide/cli-reference/#ili2py","title":"ili2py","text":"<p>Usage:</p> <pre><code>ili2py [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  -v, --verbose  Print debug information\n  -V, --version  Show the version and exit.\n  --help         Show this message and exit.\n</code></pre>"},{"location":"user_guide/cli-reference/#diagram","title":"diagram","text":"<p>Parses an arbitrary IMD16 and creates a diagram of selected flavour representing the selected models.</p> <p>Usage:</p> <pre><code>ili2py diagram [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -i, --imd TEXT                  full path to IMD16 file  [required]\n  -o, --output_folder TEXT        Path to the folder where the diagram should\n                                  be written to. The folder will be created if\n                                  not existing.  [required]\n  -f, --flavour TEXT              the desired flavour (one of mermaid,\n                                  plantuml, plantuml_role_members, dot)\n                                  [default: mermaid]\n  -d, --direction TEXT            the desired direction, depending on the\n                                  selected flavour (one of mermaid: ['LR',\n                                  'RL', 'TB', 'BT'], plantuml: ['top to\n                                  bottom', 'left to right'],\n                                  plantuml_role_members: ['top to bottom',\n                                  'left to right'], dot: [])\n  -l, --linetype TEXT             the desired linetype, depending on the\n                                  selected flavour (one of mermaid: [],\n                                  plantuml: ['polyline', 'ortho', 'spline'],\n                                  plantuml_role_members: ['polyline', 'ortho',\n                                  'spline'], dot: [])\n  -n, --file_name TEXT            The name of the output diagram. The postfix\n                                  (md, puml, etc. is added automatically due\n                                  to selected flavour).  [default: diagram]\n  -m, --models TEXT               Model names separated by comma. This is used\n                                  to filter the content of the resulting\n                                  diagram. If not provided, the full tree will\n                                  be drawn. NOTE: This works in conjunction\n                                  with the depth parameter\n  -s, --spacing-line-length INTEGER\n                                  The length of the drawn connectors between\n                                  the diagram nodes. NOTE: Currently this only\n                                  influences plantuml diagrams!  [default: 2]\n  --depth INTEGER                 The depth how the diagram should be drawn in\n                                  reference to the level of imports. 0 is the\n                                  model itself, 1 the model itself and all\n                                  models its importing and so on. NOTE: This\n                                  can be used in conjunction to the model\n                                  names to add arbitrary models to the\n                                  diagram.\n  -h, --help                      Show this message and exit.\n</code></pre>"},{"location":"user_guide/cli-reference/#python-classes","title":"python-classes","text":"<p>Parses an arbitrary imd and creates a library of python classes which represents a typed interface to the complete construction.</p> <p>Usage:</p> <pre><code>ili2py python-classes [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -i, --imd TEXT            full path to imd file  [required]\n  -o, --output_folder TEXT  Path to where the python package should be written\n                            [required]\n  -l, --library_name TEXT   Library name which will be used to assemble all\n                            python structures in.  [required]\n  -h, --help                Show this message and exit.\n</code></pre>"},{"location":"user_guide/diagram/","title":"Diagrams","text":"<p>This program generates diagrams from IMD16. The following section gives an overview about what formats are supported and the limitations.</p> <p>Info</p> <p>Be aware, this project is not meant to be used to create UML-Diagrams you can graphically edit later. It trys to produce the best automatic diagram with the different solutions instead. The approach is positioned more towards automation and forced regeneration of diagrams in a developer friendly way. Change the source (ili file) and regenerate. Never beautify by hand.</p>"},{"location":"user_guide/diagram/#mermaid","title":"Mermaid","text":"<p>Mermaid is well known and widely used. Its strength is the wide support in many development tools (Ide's, github, gitlab, ...).</p> <p>The format is a markdown code snippet. See mermaid documentation for details.</p> <p>Note</p> <p>The mermaid class diagram capabilities are limited. In addition, they depend heavily on the renderer you use to generate the diagram out of the markdown. That may be the plugin of your Ide, your browser or something else.</p>"},{"location":"user_guide/diagram/#limitations","title":"Limitations","text":"<p>Currently, known limitations are:</p> <ul> <li>Nesting of namespaces is not supported   by mermaid.</li> <li>Potentially broken self references (awkward rendering of Cardinalities, strange positioning of connectors).</li> <li>routing of connectors between classes is a bit flaky especially when it comes to larger diagrams</li> <li>Some renderers do not allow '.' in names of namespaces!</li> </ul> <p></p>"},{"location":"user_guide/diagram/#plantuml","title":"PlantUML","text":"<p>PlantUML is a non-interactive tool which renders a specific syntax text file into the desired output. The aim is automation here too. We want to transform the understanding of imd16 into an uml diagram without any further tuning. This is, what PlantUML is good for. It renders quickly and produces nice outputs even on larger diagrams with a lot of content. Especially the routing of the connectors is looking better than with mermaid.</p> <p></p>"},{"location":"user_guide/diagram/#plantuml-role-members","title":"PlantUML Role Members","text":"<p>This is a variant of the standard plantuml above. It tries to keep things clean by adding the information of roles and their multiplicity in the frame of the class. Even if this is not pure UML anymore it improves readability on messy and complex diagrams.</p> <p></p>"},{"location":"user_guide/python_classes/","title":"Python Classes","text":"<p>This program generates a standalone and fully typed python library from IMD16. The following section gives an overview about the why and how.</p>"},{"location":"user_guide/python_classes/#intro","title":"Intro","text":"<p>All started back in 2023 with some quick and dirty prototypes and lead to a report. This was backed by the cantons Neuch\u00e2tel and Basel-Landschaft.</p> <p>One outcome back then was that dataclasses are the best toolset to describe data structures in python. Because it is natively embedded and offers a wide range of flexible subsequent usage.</p> <p>The idea was born to reflect the constructs of an Interlis model (ili) with those python dataclasses.</p> <p>We could directly build a compiler with antlr in python to read those ili files into python structures. Topping up only what we need one after another. That would have been the easy way.</p> <p>We decided to go the hard way and implement the knowledge of the Interlis IlisMeta16 Model first instead. in terms of sustainability this would be the right way to do. (And it is the dedicated usecase for the metamodel.)</p>"},{"location":"user_guide/python_classes/#the-library","title":"The library","text":"<p>The library created by ili2py is fully self containing. That means, once created it has the full knowledge of the Interlis model and all subsequent dependencies. That is a really important point. You can use the resulting library in your python code without any dependencies. Not even ili2py itself. The only thing you need is a python interpreter (3.12+ recommended).</p>"},{"location":"user_guide/python_classes/#structure","title":"Structure","text":"<p>Its structure is a normal pythonic structure. Each model is defined in a sub package (folder) of the library. Each topic is a python module (python file) in its model folder. Domain definitions are stored in the <code>__init__.py</code> files.</p> <p></p>"},{"location":"user_guide/python_classes/#documentation","title":"Documentation","text":"<p>All documentation is transparently transported to its python twins.</p> <p></p> <p>The inline documentation follows the widely known and used GoogleStyle which offers a supreme readability in the code itself. But also is supported in all major IDE's out of the box.</p> <p></p> <p>Info</p> <p>Using the GoogleStyle py doc strings also enables seamless integration in automatically built documentations.</p>"},{"location":"user_guide/python_classes/#value-lists","title":"Value lists","text":"<p>Value lists are implemented as pure python enumerations and are therefore perfectly prepared for native subsequent usage.</p> <p></p>"},{"location":"user_guide/python_classes/#types","title":"Types","text":"<p>The whole library is typed. Types are self containing in the libraries network of linked dataclasses. However, at the end of each tree path there is a native pythonic type. No external types are used. Besides the types itself the library also transparently transports the information about type restrictions and formats from the interlis model. Associations are typed as references to keep the tree clean and avoid circular dependencies.</p> <p></p>"},{"location":"user_guide/python_classes/#geometries","title":"Geometries","text":"<p>Geometries are a core feature of interlis. One goal of the built library is to give easy and comfortable access to the geometric elements in the model. So each class can provide info about its geometric attributes. And each geometric attribute can provide detailed information about its kind of geometry. This is a good preparation for tools which subsequently will use ili2py later.</p> <p></p>"},{"location":"user_guide/python_classes/#constraints","title":"Constraints","text":"<p>The detailed implementation of constraints is another key feature in interlis. Since ili2py does not validate anything, constraints are only transported as information at its dedicated pythonic twin elements. The model of the constraints mirrors the IlisMeta16 model constraints part. Classes to interpret this part are delivered in the library as well.</p> <p></p>"},{"location":"user_guide/python_classes/#metaattributes","title":"MetaAttributes","text":"<p>These things are often used to implement behaviour which was not intended by interlis in the first place. The information is forwarded to each pythonic twin transparently.</p> <p></p>"},{"location":"user_guide/start/","title":"Get started","text":"<p>In general there are 2 ways to use ili2py:</p> <ul> <li>CLI pure python</li> <li>CLI binary (linux, window, macos)</li> <li>Docker container</li> <li>as a library</li> </ul>"},{"location":"user_guide/start/#quickstart","title":"Quickstart","text":"<p>The following sections will guide you to quickstart the project.</p> <p>Tip</p> <p>If you are on windows, you need to change the direction of the slashes in the commands you execute!</p> <p>All following commands are executed from the project root.</p>"},{"location":"user_guide/start/#python","title":"Python","text":"<p>Assuming you have a working python and virtualenv installed on your system.</p> <pre><code>virtualenv .venv\n.venv/bin/pip install --upgrade pip wheel setuptools\n.venv/bin/pip install -e .\n# show help about ili2py in general\n.venv/bin/python -m ili2py.cli\n# show version of ili2py\n.venv/bin/python -m ili2py.cli -V\n# show help about diagram tool\n.venv/bin/python -m ili2py.cli diagram --help\n# create plantuml diagram with one model selected\n.venv/bin/python -m ili2py.cli diagram -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f plantuml -o .generated -m OeREBKRMtrsfr_V2_0\n# create plantuml diagram with all models which are related\n.venv/bin/python -m ili2py.cli diagram -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f plantuml -o .generated\n# create plantuml diagram with 2 models selected\n.venv/bin/python -m ili2py.cli diagram -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f plantuml -o .generated -m OeREBKRMtrsfr_V2_0,OeREBKRM_V2_0\n# create mermaid diagram with one model selected\n.venv/bin/python -m ili2py.cli diagram -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f mermaid -o .generated -m OeREBKRMtrsfr_V2_0\n# create mermaid diagram with all models which are related\n.venv/bin/python -m ili2py.cli diagram -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f mermaid -o .generated\n# create mermaid diagram with 2 models selected\n.venv/bin/python -m ili2py.cli diagram -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f mermaid -o .generated -m OeREBKRMtrsfr_V2_0,OeREBKRM_V2_0\n# show debug output while generating diagram\n.venv/bin/python -m ili2py.cli -v diagram -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f plantuml -o .generated\n# capture log into a log file\n.venv/bin/python -m ili2py.cli -v diagram -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f plantuml -o .generated &gt; ili2py.log\n\n# show help about python class generation tool\n.venv/bin/python -m ili2py.cli python-classes --help\n# generates complete set of python classes for a model\n.venv/bin/python -m ili2py.cli python-classes -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o .generated -l interface\n# if you have a python project which you want to include the interface directly you should name it regardingly (dotted python path).\n# Of course you need to copy the output to the correct path then, or create it alread in the right place.\n.venv/bin/python -m ili2py.cli python-classes -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o .generated -l ili2py.interfaces.interlis.OeREBKRMtrsfr_V2_0\n# show debug output while generating python classes\n.venv/bin/python -m ili2py.cli -v python-classes -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o .generated -l interface\n# capture log into a log file\n.venv/bin/python -m ili2py.cli -v python-classes -i tests/data/models/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o .generated -l interface &gt; ili2py.log\n</code></pre>"},{"location":"user_guide/start/#docker","title":"Docker","text":"<pre><code>docker build -t ili2py:local-dev .\n\n# show help about ili2py in general\ndocker run --rm -ti ili2py:local-dev\n# show version of ili2py\ndocker run --rm -ti ili2py:local-dev -V\n# show help about diagram tool\ndocker run --rm -ti ili2py:local-dev diagram --help\n# create plantuml diagram with one model selected\ndocker run --rm -ti -v ./tests/data/models:/io/data -v ./.generated:/io/generated ili2py:local-dev diagram -i /io/data/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f plantuml -o /io/generated -m OeREBKRMtrsfr_V2_0\n# create plantuml diagram with all models which are related\ndocker run --rm -ti -v ./tests/data/models:/io/data -v ./.generated:/io/generated ili2py:local-dev diagram -i /io/data/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f plantuml -o /io/generated\n# create plantuml diagram with 2 models selected\ndocker run --rm -ti -v ./tests/data/models:/io/data -v ./.generated:/io/generated ili2py:local-dev diagram -i /io/data/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f plantuml -o /io/generated -m OeREBKRMtrsfr_V2_0,OeREBKRM_V2_0\n# create mermaid diagram with one model selected\ndocker run --rm -ti -v ./tests/data/models:/io/data -v ./.generated:/io/generated ili2py:local-dev diagram -i /io/data/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f mermaid -o /io/generated -m OeREBKRMtrsfr_V2_0\n# create mermaid diagram with all models which are related\ndocker run --rm -ti -v ./tests/data/models:/io/data -v ./.generated:/io/generated ili2py:local-dev diagram -i /io/data/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f mermaid -o /io/generated\n# create mermaid diagram with 2 models selected\ndocker run --rm -ti -v ./tests/data/models:/io/data -v ./.generated:/io/generated ili2py:local-dev diagram -i /io/data/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -f mermaid -o /io/generated -m OeREBKRMtrsfr_V2_0,OeREBKRM_V2_0\n\n# show help about python class generation tool\ndocker run --rm -ti ili2py:local-dev python-classes --help\n# generates complete set of python classes for a model\ndocker run --rm -ti -v ./tests/data/models:/io/data -v ./.generated:/io/generated ili2py:local-dev python-classes -i /io/data/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o /io/generated -l interface\n# if you have a python project which you want to include the interface directly you should name it regardingly (dotted python path).\n# Of course you need to copy the output to the correct path then, or create it alread in the right place.\ndocker run --rm -ti -v ./tests/data/models:/io/data -v ./.generated:/io/generated ili2py:local-dev python-classes -i /io/data/OeREBKRMtrsfr_V2_0/OeREBKRMtrsfr_V2_0.imd -o /io/generated -l ili2py.interfaces.interlis.OeREBKRMtrsfr_V2_0\n</code></pre>"}]}